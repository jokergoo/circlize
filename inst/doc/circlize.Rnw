% \VignetteIndexEntry{Introduction to circlize package}
% \VignetteDepends{circlize}
% \VignetteKeywords{circos R}
% \VignetteKeywords{ideogram}
% \VignetteKeywords{circlize}
% \VignettePackage{circlize}

\documentclass{article}

\title{An introduction to {\tt circlize} package}

\author{Zuguang Gu {\tt <z.gu@dkfz.de>}\\ German Cancer Research Center,\\ Heidelberg, Germany}

\usepackage{Sweave}
\usepackage{hyperref}

\begin{document}

\maketitle 

\section{Introduction}
Circos layout (\url{http://circos.ca}) is very useful to represent complicated information, especially for genomic data.
It is not only a way to visualize data, but also enhances the representation of scientific results into a level of aesthetics.
The {\tt circlize} package implements the circos layout in R. The advantage is that R is natural born to draw statistical
graphs, thus, types of plottings are not restricted by the package but by user's inspiration. The {\tt circlize} package allocates
and illustrates data which is from a certain category into a cell inside a circle and makes you
felling that you are plotting figures in a normal plotting coordinate.

Since most of the figures are composed of simple graphs, such as points, lines, polygon (for filled color) {\it et al},
so we just need to implement those low-level functions for drawing figures in circos layout.

Currently there are following functions that can be used for plotting, they are similar to the functions without {\tt "circos."}
prefix from the traditional graph engine:

\begin{itemize}
  \item {\tt circos.points}: draw points in a cell, similar as {\tt points}.
  \item {\tt circos.lines}: draw lines in a cell, similar as {\tt lines}.
  \item {\tt circos.rect}: draw rectangle in a cell, similar as {\tt rect}.
  \item {\tt circos.polygon}: draw polygon in a cell, similar as {\tt polygon}.
  \item {\tt circos.text}: draw text in a cell, similar as {\tt text}.
  \item {\tt circos.axis}: draw axis in a cell, functionally similar as {\tt axis} but with more features.
  \item {\tt circos.link}: this maybe the unique feature for circos layout to represent relationships between elements.
\end{itemize}

For drawing points, lines and text in cells through the whole track (among several sectors), the following functions are available:

\begin{itemize}
  \item {\tt circos.trackPoints}: this can be replaced by {\tt circos.points} through a {\tt for} loop.
  \item {\tt circos.trackLines}: this can be replaced by {\tt circos.lines} through a {\tt for} loop.
  \item {\tt circos.trackText}: this can be replaced by {\tt circos.text} through a {\tt for} loop.
\end{itemize}

Also, the function drawing histograms in the whole track is available:

\begin{itemize}
  \item {\tt circos.trackHist}
\end{itemize}

Functions to arrange the circos layout:

\begin{itemize}
  \item {\tt circos.trackPlotRegion}: create plotting regions of cells in one track
  \item {\tt circos.updatePlotRegion}: update an existed cell
  \item {\tt circos.par}: circos parameters
  \item {\tt circos.clear}: reset circos parameters and internal variables
\end{itemize}

Theoretically, you are able to draw most kinds of circos figures by the above functions. 
As you can see, all figures in the four vignettes are generated by {\tt circlize} package.

The following part of this vignette is structured as follows: First there is an example
to give a quick glance of how to draw a circos layout. Then it tells you the basic principle
(or the order of using the circos functions) for drawing. After that there are detailed explainations
of circos parameters, coordinates and low-level functions. Finally it would tell you some tricks
for drawing more complicated circos plot.

\section{A quick glance}
Following is an example to show the basic feature and usage of {\tt circlize} package. 
First generate some data. There needs to have a factor to represent categories,
values on x-axis, and values on y-axis.

<<label=figexample1, echo=TRUE, eval=FALSE>>=
set.seed(12345)
n = 1000
a = data.frame(factor = sample(letters[1:8], n, replace = TRUE),
    x = rnorm(n), y = runif(n))
@

Initialize the layout. In this step, the {\tt circos.initialize} function allocates sectors along
the circle according to ranges of x-values in different categories. E.g,
if there are two categories, range for x-values in the first category is {\tt c(0, 2)}
and range for x-values in the second category is {\tt c(0, 1)}, the first category
would hold approximately $67\%$ areas of the circle.
Here we only need x-values because all cells in a sector share the same
x-ranges.

<<label=figexample2, echo=TRUE, eval=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1), lwd = 0.1, cex = 0.7)
circos.par("default.track.height" = 0.1)
circos.initialize(factors = a$factor, x = a$x)
@

Draw the first track (figure \ref{fig:example}, top left). Before drawing any track we need to know that all tracks should firstly be created by {\tt circos.trackPlotRegion}, then
those low-level functions can be applied. X-lims for cells in the track have already been defined in the initialization step, 
so here we only need to specify the y-lims for each cell, either by {\tt y}
or {\tt ylim} argument. 

We also draw axis for each cell in the first track, The axis for each cell is drawn by {\tt panel.fun} argument. 
{\tt circos.trackPlotRegion} creates plotting region cell by cell and the {\tt panel.fun}
is actually executed after the creation of the plotting region for a cell immediately. So {\tt panel.fun} actually means
drawing graphs in the ``current cell''. After that, draw points
through the whole track by {\tt circos.trackPoints}. Finally, add two texts in a certain cell
(the cell is specified by {\tt sector.index} and {\tt track.index} argument). In drawing the second
text, we do not specify {\tt track.index} because the package knows we are now in the first track.

Here what should be noted is that the first track has a index number of 1.
Then an internal variable which traces the tracks would set the current track index to 1. So if the track
index is not specified in the plotting functions such as {\tt circos.trackPoints} and {\tt circos.text}
which are called after the creation of the track, the current track index would be assigned internally.
 (details would be explained in the following sections).

<<label=figexample3, echo=TRUE, eval=FALSE>>=
circos.trackPlotRegion(factors = a$factor, y = a$y,
    panel.fun = function(x, y) {
        circos.axis()
})
col = rep(c("#FF0000", "#00FF00"), 4)
circos.trackPoints(a$factor, a$x, a$y, col = col,
    pch = 16, cex = 0.5)
circos.text(-1, 0.5, "left", sector.index = "a", track.index = 1)
circos.text(1, 0.5, "right", sector.index = "a")
@

Draw the second track (figure \ref{fig:example}, top right). There are histograms among the track. The {\tt circos.trackHist}
can also create a new track because drawing histogram is really high-level. The track index for this track is 2.

<<label=figexample4, echo=TRUE, eval=FALSE>>=
bgcol = rep(c("#EFEFEF", "#CCCCCC"), 4)
circos.trackHist(a$factor, a$x, bg.col = bgcol, col = NA)
@

Draw the third track (figure \ref{fig:example}, middle left). Different background colors for cells can be assigned. So it may highlight some
features of the {\tt circlize} package. Here some meta data for a cell can be obtained by {\tt get.cell.meta.data}. This function needs
{\tt sector.index} and {\tt track.index} arguments, and if they are not specified, it means
it is the current sector index and the current track index.

<<label=figexample5, echo=TRUE, eval=FALSE>>=
circos.trackPlotRegion(factors = a$factor, x = a$x, y = a$y,
  panel.fun = function(x, y) {
      grey = c("#FFFFFF", "#CCCCCC", "#999999")
      i = get.cell.meta.data("sector.numeric.index")
      circos.updatePlotRegion(bg.col = grey[i %% 3 + 1])
      circos.points(x[1:10], y[1:10], col = "red", pch = 16, cex = 0.6)
      circos.points(x[11:20], y[11:20], col = "blue", cex = 0.6)
  })
@

You can update an existed cell by specifying {\tt sector.index} and {\tt track.index} in {\tt circos.updatePlotRegion}.
The function erases graphs which have been drawn. Here we erase graphs in one cell in track 2, sector {\tt d}
and re-draw some points (figure \ref{fig:example}, middle right). {\tt circos.updatePlotRegion} can not modify the {\tt xlim}
and {\tt ylim} of the cell as well as other settings related to the position of the cell.

<<label=figexample6, echo=TRUE, eval=FALSE>>=
circos.updatePlotRegion(sector.index = "d", track.index = 2)
circos.points(x = -2:2, y = rep(0, 5))
@}

Draw the fouth track (figure \ref{fig:example}, bottom left). Here you can choose different line types.

<<label=figexample7, echo=TRUE, eval=FALSE>>=
circos.trackPlotRegion(factors = a$factor, y = a$y)
circos.trackLines(a$factor[1:100], a$x[1:100], a$y[1:100], type = "h")
@

Draw links (figure \ref{fig:example}, bottom right). Links can be from point to point, point to interval or interval to interval.
Some of the arguments would be explained in the following sections.

<<label=figexample8, echo=TRUE, eval=FALSE>>=
circos.link("a", 0, "b", 0, top.ratio = 0.9)
circos.link("c", c(-0.5, 0.5), "d", c(-0.5,0.5), col = "red",
    border = "blue", top.ratio = 0.2)
circos.link("e", 0, "g", c(-1,1), col = "green", lwd = 2, lty = 2)
circos.clear()
@

\begin{figure}
\begin{center}
<<label=figexample, fig = TRUE, echo = FALSE, height = 18, width=12, results=hide>>=


set.seed(12345)
n = 1000
a = data.frame(factor = sample(letters[1:8], n, replace = TRUE),
    x = rnorm(n), y = runif(n))
library(circlize)
par(mar = c(1, 1, 1, 1), lwd = 0.1)
layout(rbind(1:2, 3:4, 5:6))

######################################
circos.par("default.track.height" = 0.1)
circos.initialize(factors = a$factor, x = a$x)
circos.trackPlotRegion(factors = a$factor, y = a$y,
    panel.fun = function(x, y) {
        circos.axis()
})
col = rep(c("#FF0000", "#00FF00"), 4)
circos.trackPoints(a$factor, a$x, a$y, col = col,
    pch = 16, cex = 0.5)
circos.text(-1, 0.5, "left", sector.index = "a", track.index = 1)
circos.text(1, 0.5, "right", sector.index = "a")
circos.clear()

###########################################

circos.par("default.track.height" = 0.1)
circos.initialize(factors = a$factor, x = a$x)
circos.trackPlotRegion(factors = a$factor, y = a$y,
    panel.fun = function(x, y) {
        circos.axis()
})
col = rep(c("#FF0000", "#00FF00"), 4)
circos.trackPoints(a$factor, a$x, a$y, col = col,
    pch = 16, cex = 0.5)
circos.text(-1, 0.5, "left", sector.index = "a", track.index = 1)
circos.text(1, 0.5, "right", sector.index = "a")
bgcol = rep(c("#EFEFEF", "#CCCCCC"), 4)
circos.trackHist(a$factor, a$x, bg.col = bgcol, col = NA)
circos.clear()

###########################################
circos.par("default.track.height" = 0.1)
circos.initialize(factors = a$factor, x = a$x)
circos.trackPlotRegion(factors = a$factor, y = a$y,
    panel.fun = function(x, y) {
        circos.axis()
})
col = rep(c("#FF0000", "#00FF00"), 4)
circos.trackPoints(a$factor, a$x, a$y, col = col,
    pch = 16, cex = 0.5)
circos.text(-1, 0.5, "left", sector.index = "a", track.index = 1)
circos.text(1, 0.5, "right", sector.index = "a")
bgcol = rep(c("#EFEFEF", "#CCCCCC"), 4)
circos.trackHist(a$factor, a$x, bg.col = bgcol, col = NA)
circos.trackPlotRegion(factors = a$factor, x = a$x, y = a$y,
  panel.fun = function(x, y) {
      grey = c("#FFFFFF", "#CCCCCC", "#999999")
      i = get.cell.meta.data("sector.numeric.index")
      circos.updatePlotRegion(bg.col = grey[i %% 3 + 1])
      circos.points(x[1:10], y[1:10], col = "red", pch = 16, cex = 0.6)
      circos.points(x[11:20], y[11:20], col = "blue", cex = 0.6)
  })
circos.clear()

##############################################
circos.par("default.track.height" = 0.1)
circos.initialize(factors = a$factor, x = a$x)
circos.trackPlotRegion(factors = a$factor, y = a$y,
    panel.fun = function(x, y) {
        circos.axis()
})
col = rep(c("#FF0000", "#00FF00"), 4)
circos.trackPoints(a$factor, a$x, a$y, col = col,
    pch = 16, cex = 0.5)
circos.text(-1, 0.5, "left", sector.index = "a", track.index = 1)
circos.text(1, 0.5, "right", sector.index = "a")
bgcol = rep(c("#EFEFEF", "#CCCCCC"), 4)
circos.trackHist(a$factor, a$x, bg.col = bgcol, col = NA)
circos.trackPlotRegion(factors = a$factor, x = a$x, y = a$y,
  panel.fun = function(x, y) {
      grey = c("#FFFFFF", "#CCCCCC", "#999999")
      i = get.cell.meta.data("sector.numeric.index")
      circos.updatePlotRegion(bg.col = grey[i %% 3 + 1])
      circos.points(x[1:10], y[1:10], col = "red", pch = 16, cex = 0.6)
      circos.points(x[11:20], y[11:20], col = "blue", cex = 0.6)
  })
circos.updatePlotRegion(sector.index = "d", track.index = 2)
circos.points(x = -2:2, y = rep(0, 5))
circos.clear()

################################################

circos.par("default.track.height" = 0.1)
circos.initialize(factors = a$factor, x = a$x)
circos.trackPlotRegion(factors = a$factor, y = a$y,
    panel.fun = function(x, y) {
        circos.axis()
})
col = rep(c("#FF0000", "#00FF00"), 4)
circos.trackPoints(a$factor, a$x, a$y, col = col,
    pch = 16, cex = 0.5)
circos.text(-1, 0.5, "left", sector.index = "a", track.index = 1)
circos.text(1, 0.5, "right", sector.index = "a")
bgcol = rep(c("#EFEFEF", "#CCCCCC"), 4)
circos.trackHist(a$factor, a$x, bg.col = bgcol, col = NA)
circos.trackPlotRegion(factors = a$factor, x = a$x, y = a$y,
  panel.fun = function(x, y) {
      grey = c("#FFFFFF", "#CCCCCC", "#999999")
      i = get.cell.meta.data("sector.numeric.index")
      circos.updatePlotRegion(bg.col = grey[i %% 3 + 1])
      circos.points(x[1:10], y[1:10], col = "red", pch = 16, cex = 0.6)
      circos.points(x[11:20], y[11:20], col = "blue", cex = 0.6)
  })
circos.updatePlotRegion(sector.index = "d", track.index = 2)
circos.points(x = -2:2, y = rep(0, 5))
circos.trackPlotRegion(factors = a$factor, y = a$y)
circos.trackLines(a$factor[1:100], a$x[1:100], a$y[1:100], type = "h")
circos.clear()

###################################################

circos.par("default.track.height" = 0.1)
circos.initialize(factors = a$factor, x = a$x)
circos.trackPlotRegion(factors = a$factor, y = a$y,
    panel.fun = function(x, y) {
        circos.axis()
})
col = rep(c("#FF0000", "#00FF00"), 4)
circos.trackPoints(a$factor, a$x, a$y, col = col,
    pch = 16, cex = 0.5)
circos.text(-1, 0.5, "left", sector.index = "a", track.index = 1)
circos.text(1, 0.5, "right", sector.index = "a")
bgcol = rep(c("#EFEFEF", "#CCCCCC"), 4)
circos.trackHist(a$factor, a$x, bg.col = bgcol, col = NA)
circos.trackPlotRegion(factors = a$factor, x = a$x, y = a$y,
  panel.fun = function(x, y) {
      grey = c("#FFFFFF", "#CCCCCC", "#999999")
      i = get.cell.meta.data("sector.numeric.index")
      circos.updatePlotRegion(bg.col = grey[i %% 3 + 1])
      circos.points(x[1:10], y[1:10], col = "red", pch = 16, cex = 0.6)
      circos.points(x[11:20], y[11:20], col = "blue", cex = 0.6)
  })
circos.updatePlotRegion(sector.index = "d", track.index = 2)
circos.points(x = -2:2, y = rep(0, 5))
circos.trackPlotRegion(factors = a$factor, y = a$y)
circos.trackLines(a$factor[1:100], a$x[1:100], a$y[1:100], type = "h")
circos.link("a", 0, "b", 0, top.ratio = 0.9)
circos.link("c", c(-0.5, 0.5), "d", c(-0.5,0.5), col = "red",
    border = "blue", top.ratio = 0.2)
circos.link("e", 0, "g", c(-1,1), col = "green", lwd = 2, lty = 2)
circos.clear()

layout(rbind(1))

@
\end{center}
\caption{An example for circos layout}
\label{fig:example}
\end{figure}

The final figure looks like figure \ref{fig:example}.

\begin{figure}
\begin{center}
<<label=figorder, fig = TRUE, echo = FALSE, height=6, width=7, results=hide>>=
library(circlize)
layout(rbind(1:4, 5:8, 9:12), width = c(1.5, 2, 1.5, 2))
par(mar = c(1, 1, 1, 1), xpd = NA)

plot(c(0, 1), c(0, 1), type = "n", ann = FALSE, axes = FALSE)
text(0.5, 0.5, "circos.initialize", adj = c(0.5, 0.5), cex = 1.2)

circos.par(gap.degree = 5)
circos.initialize(1:4, xlim = rbind(c(0, 1), c(0, 2), c(0, 3), c(0, 4)))
circos.trackPlotRegion(ylim = c(0, 1), bg.border = NA)
for(i in 1:4) {
    de = get.cell.meta.data("cell.start.degree", i, 1) - circos.par("gap.degree")/2
    lines(c(0, cos(de/180*pi)), c(0, sin(de/180*pi)), lty = 2, col = "#999999")
}
draw.sector(start.degree = 0, end.degree = 360, rou1 = 1, col = NA, lty = 2, border = "#999999")
circos.clear()

plot(c(0, 1), c(0, 1), type = "n", ann = FALSE, axes = FALSE)
text(0.5, 0.5, "circos.trackPlotRegion", adj = c(0.5, 0.5), cex = 1.2)

circos.par(gap.degree = 5)
circos.initialize(1:4, xlim = rbind(c(0, 1), c(0, 2), c(0, 3), c(0, 4)))
circos.trackPlotRegion(ylim = c(0, 1))
circos.clear()

plot(c(0, 1), c(0, 1), type = "n", ann = FALSE, axes = FALSE)
text(0.5, 0.5, "circos.points", adj = c(0.5, 0.5), cex = 1.2)

circos.par(gap.degree = 5)
circos.initialize(1:4, xlim = rbind(c(0, 1), c(0, 2), c(0, 3), c(0, 4)))
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    xlim = get.cell.meta.data("xlim")
    circos.points(runif(20)*(xlim[2] - xlim[1])+xlim[1], runif(20), pch = 16)
})
circos.clear()

plot(c(0, 1), c(0, 1), type = "n", ann = FALSE, axes = FALSE)
text(0.5, 0.5, "circos.trackPlotRegion", adj = c(0.5, 0.5), cex = 1.2)

circos.par(gap.degree = 5)
circos.initialize(1:4, xlim = rbind(c(0, 1), c(0, 2), c(0, 3), c(0, 4)))
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    xlim = get.cell.meta.data("xlim")
    circos.points(runif(20)*(xlim[2] - xlim[1])+xlim[1], runif(20), pch = 16)
})
circos.trackPlotRegion(ylim = c(0, 1))
circos.clear()

plot(c(0, 1), c(0, 1), type = "n", ann = FALSE, axes = FALSE)
text(0.5, 0.5, "circos.points", adj = c(0.5, 0.5), cex = 1.2)

circos.par(gap.degree = 5)
circos.initialize(1:4, xlim = rbind(c(0, 1), c(0, 2), c(0, 3), c(0, 4)))
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    xlim = get.cell.meta.data("xlim")
    circos.points(runif(20)*(xlim[2] - xlim[1])+xlim[1], runif(20), pch = 16)
})
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    xlim = get.cell.meta.data("xlim")
    circos.points(runif(20)*(xlim[2] - xlim[1])+xlim[1], runif(20), pch = 16)
})
circos.clear()

plot(c(0, 1), c(0, 1), type = "n", ann = FALSE, axes = FALSE)
text(0.5, 0.5, "...\ncircos.clear", adj = c(0.5, 0.5), cex = 1.2)

layout(rbind(1))
par(xpd = FALSE)

@
\end{center}
\caption{Order of drawing circos layout}
\label{fig:order}
\end{figure}

<<label=figtransformation, echo=FALSE, eval=FALSE>>=
library(circlize)
layout(cbind(c(1, 0, 2, 0, 3)), height = c(1,0.25,1, 0.25, 2))
par(mar = c(2, 2, 2, 2))
x = 1:10
y = rnorm(10)
plot(x, y, type = "l", axes = FALSE, ann = FALSE)
text(2, 0, "text", cex = 2)
rect(5, -1, 7, 1)
box()
axis(side = 1)

par(mar = c(1, 1, 1, 1))
factors = letters[1:3]
circos.par("canvas.xlim" = c(-sqrt(3)/2, sqrt(3)/2), "canvas.ylim" = c(1/2*0.6, 1), start.degree = 30, "track.margin" = c(0, 0), "gap.degree" = 0, "clock.wise" = FALSE, points.overflow.warning = FALSE)
circos.initialize(factors = factors, xlim = c(1, 10))
circos.trackPlotRegion(factors = factors, ylim = range(y), track.height = 0.4, bg.border = NA)
circos.updatePlotRegion(sector.index = "a", track.index = 1, bg.border = "black")
circos.lines(x, y, sector.index = "a", track.index = 1, straight = TRUE)
circos.text(2, 0, "text", cex = 2)
circos.rect(5, -1, 7, 1)
circos.axis(h = "bottom")
circos.clear()

par(xpd = NA)
arrows(0, 1.33, 0, 1.07, code = 2)

par(mar = c(3, 3, 3, 3))
factors = letters[1:3]
circos.initialize(factors = factors, xlim = c(1, 10))
circos.trackPlotRegion(factors = factors, ylim = range(y), track.height = 0.4)
circos.updatePlotRegion(sector.index = "c", track.index = 1, bg.border = "black")
circos.lines(x, y, sector.index = "c", track.index = 1, straight = TRUE)
circos.text(2, 0, "text", cex = 2)
circos.rect(5, -1, 7, 1)
circos.axis(h = "bottom")
circos.clear()
box()
axis(side = 1)
axis(side = 2)
arrows(0, 1.5, 0, 1.07, code = 2)
@

\begin{figure}
\begin{center}
<<label=figtransformation, fig = TRUE, echo = FALSE, height=5.64, width=2.5, results=hide>>=
<<figtransformation>>
@
\end{center}
\caption{Transformation between different coordinates. Top: data coordinate; Middle: polar coordinate; Bottom: canvas coordinate.}
\label{fig:transformation}
\end{figure}

\section{Details}
In this section, more details of the package would be explained.

\subsection{Rules to draw the circos layout}
The rules for drawing the circos layout is rather simple. It follows the sequence of
``initialize - create track - draw graphs - create track - draw graphs - ... - clear'' (figure \ref{fig:order}).
See following:

\begin{enumerate}
  \item Initialize the layout using {\tt circos.initialize}. Since circos layout in fact visualizes data which is in categories,
        there should be a factor and a x-range to allocate categories into sectors.
  \item Create plotting regions for the new track and apply plottings. The new track is created just inside
        the previously created one and the index of the track is added by 1 automatically. Only after the creation of the track can you
        add other graphs on it. There are three ways to do the plotting job.
        \begin{enumerate}
            \item After the creation of the track. use low-level function like {\tt circos.points},
                  {\tt circos.lines}, ... to draw graphs cell by cell. It allways involves
                  a {\tt for} loop.
            \item Use {\tt circis.trackPoints}, {\tt circos.trackLines}, ... to draw same style
                  of graphs through all cells simultaneously. However, it is not recommended because
                  it would make you a little confused and also it cannot draw complicated graphs.
            \item Use {\tt panel.fun} argument in {\tt circos.trackPlotRegion} to draw
                  graphs immediately after the creation of certain cell. {\tt panel.fun} needs
                  two arguments {\tt x} and {\tt y} which are x-values and y-values that
                  in the current category. This subset operation of data would be applied internally.
        \end{enumerate}
        Plotting regions for cells that have been created can be updated by {\tt circos.updatePlotRegion}.
        {\tt circos.updatePlotRegion} will erase every that you have already plotted in the plotting region of the cell.
        
        Low level functions such as {\tt circos.points} can be applied on any created cell by specifying
        {\tt sector.index} and {\tt track.index}.
  \item Call {\tt circos.clear} to do cleanings.
\end{enumerate}

Codes for the circos layout drawing rules would look like (pseudo code):
\begin{Schunk}
\begin{Sinput}
> circos.initialize(factors, xlim)
> circos.trackPlotRegion(factors, ylim)
> for(sector.index in all.sector.index) {
+     circos.points(x1, y1, sector.index)
+     circos.lines(x2, y2, sector.index)
+ }
\end{Sinput}
\end{Schunk}

or like following:
\begin{Schunk}
\begin{Sinput}
> circos.initialize(factors, xlim)
> circos.trackPlotRegion(factors, ylim)
> circos.trackPoints(factors, x1, y1)
> circos.trackLines(factors, x2, y2)
\end{Sinput}
\end{Schunk}

or like following. This the most natural way I feel.
\begin{Schunk}
\begin{Sinput}
> circos.initialize(factors, xlim)
> circos.trackPlotRegion(factors, x, y, ylim,
+   panel.fun = function(x, y) {
+     circos.points(x, y)
+     circos.lines(x, y)
+ })
\end{Sinput}
\end{Schunk}

There is several internal variables keeping tracing of the current sector and track when applying {\tt circos.trackPlotRegion} and {\tt circos.updatePlotRegion}.
So although functions like {\tt circos.points}, {\tt circos.lines} need to specify the index for sector and track,
they will take the current calculated ones by default. As a result,
if you draw points, lines, text, {\it et al} just after the creation of the track or cell, you do not need to set the sector
index and the track index explicitly and it is just drawn in the most nearly created cell. Note again, only {\tt circos.trackPlotRegion}
and {\tt circos.updatePlotRegion} would reset the current track index and sector index.

Finally, in {\tt circlize} package, function with prefix {\tt circos.track} would affect all cells in a track.

\subsection{Coordinate transformation}
There is a {\bf data coordinate} in which the range for x-axis and y-axis is the range of data,
a {\bf polar coordinate} to allocates different cells on a circle and a {\bf canvas coordinate} which really
draws the figures (figure \ref{fig:transformation}). The package would first transform the data
coordinate to a polar coordinate and finally transform into the canvas coordinate.

The finnal canvas coordinate is in fact an ordinary coordinate in R plotting system with
x-range from -1 to 1 and y-range from -1 to 1 by default.

{\it {\bf It should be noted that the circos layout is allways (or mostly except you want to draw something out of the plotting region) 
drawn inside the circle which has radius of 1 (unit
circle), from outside to inside. } }

However, for users, they only need to imagine that each cell is a normal rectangular plotting region (data coordinate) in
which x-lim and y-lim are ranges of data in the category respectively. The {\tt circlize} package would
know which cell you are drawing in and do the transformation.

<<label=figcoordinate, echo=FALSE, eval=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
factors = factor(letters[1:10], levels = sample(letters[1:10], 10))
circos.par("cell.padding" = c(0, 0, 0, 0), points.overflow.warning = FALSE)
circos.initialize(factors = factors, xlim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10))
for(l in letters[1:10]) {
    circos.rect(0,0,10,10,sector.index = l, track.index = 2, col = "#FF000040")
}

for(l in 1:4) {
    circos.rect(0,0,10,10,sector.index = "a", track.index = l, col = "#0000FF40")
}
show.index()
circos.clear()

@

\begin{figure}
\begin{center}
<<label=figcoordinate, fig = TRUE, echo = FALSE, results=hide>>=
<<figcoordinate>>
@
\end{center}
\caption{Coordinate in circos layout}
\label{fig:coordinate}
\end{figure}


\subsection{Sectors and tracks}

A circos layout is composed of sectors and tracks, as illustrated in figure \ref{fig:coordinate}.
The red circle is the track and the blue one is the sector. The intersection of a sector and 
a track is called a cell which can be thought as an imaginary plotting region for values in a certain category (data coordinate). 

Sectors are first allocated and determined by {\tt circos.initialize} and track allocation is then determined by {\tt circos.trackPlotRegion}.
{\tt circos.initialize} needs a category variable and data value which implicates the range of data in each category. The range
of data can be specified either by {\tt x} or {\tt xlim}.

\begin{Schunk}
\begin{Sinput}
> circos.initialize(factors, x)
> circos.initialize(factors, xlim)
\end{Sinput}
\end{Schunk}

There are something very important that should be noted in the initialization step. In this step, not only the width
of each sector is assigned, but also the order of each sector on the circle would be determined. 
{\bf Order of the sectors are determined by the order of levels of the factor}. So if you want to change the order
of the sectors, just change of the level of the {\tt factors} variable. The following codes would generate different figures (figure \ref{fig:factor}):

\begin{Schunk}
\begin{Sinput}
> fa = c("d", "f", "e", "c", "g", "b", "a")
> f1 = factor(fa)
> circos.initialize(factors = f1, xlim = c(0, 1))
> f2 = factor(fa, levels = fa)
> circos.initialize(factors = f2, xlim = c(0, 1))
\end{Sinput}
\end{Schunk}

\begin{figure}
\begin{center}
<<label=figfactor, fig = TRUE, echo = FALSE, width=8, height=4, results=hide>>=
library(circlize)
par(mar = c(1, 1, 1, 1), mfrow = c(1, 2))
fa = c("d", "f", "e", "c", "g", "b", "a")
f1 = factor(fa)
circos.initialize(factors = f1, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1))
show.index()
text(0, 0, "factor(fa)", adj = c(0.5, 0.5), cex = 1.3)
circos.clear()

f2 = factor(fa, levels = fa)
circos.initialize(factors = f2, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1))
show.index()
text(0, 0, "factor(fa,\nlevels = fa)", adj = c(0.5, 0.5), cex = 1.3)
circos.clear()

@
\end{center}
\caption{Different {\tt factor} order in the initialization step.}
\label{fig:factor}
\end{figure}


If {\tt x} which is the x-values corresponding
to {\tt factors} is specified, the range for x-values in different category would be calculated according to {\tt factors}
automatically. And if {\tt xlim} is specified, it should be either a matrix which has same number of rows as the length
of the level of {\tt factors} or a two-element vector. If it is a two-element vector, it would be extended to a matrix which 
has the same number of rows as the length of {\tt factors} levels. Here, every row in {\tt xlim} corresponds to the x-ranges
of a category and the order of rows in {\tt xlim} corresponds to the order of levels of {\tt factors}.

{\bf Since all cells in one sector in different tracks share the same x-ranges}, for each track, we only need to specify the y-ranges
for cells. Similar as {\tt circos.initialize}, {\tt circos.trackPlotRegion} can also receive either {\tt y} or {\tt ylim} argument
to specify the range of y-values. There is also a {\tt force.ylim} argument to sepcify whether all cells in one track should
share the same y-ranges. {\tt force.ylim} is only used along with {\tt y}.

\begin{Schunk}
\begin{Sinput}
> circos.trackPlotRegion(factors, y)
> circos.trackPlotRegion(factors, ylim)
\end{Sinput}
\end{Schunk}

In the track creation step, since all sectors are already allocated in the circle, if {\tt factors} argument is not set, 
{\tt circos.trackPlotRegion} would create plotting regions for all available sectors. Also, levels of {\tt factors} do not
need to be specified explicitly because the order of sectors has already be determined in the initialization step. If {\tt factors} is just a vector, it 
would be converted to factor automatically. And finally if users just create cells in part of sectors in the track (not all sectors), in fact, the cells in remaining
unspecified sectors would also be created, but with no borders (pretending they are not created).


<<label=figregion, echo=FALSE, eval=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1), "xaxs" = "i", "yaxs" = "i")
factors = letters[1:8]
circos.par("canvas.xlim" = c(0, 1), "canvas.ylim" = c(0, 1), "gap.degree" = 3, "start.degree" = 20, "track.margin" = c(0.05, 0.05), "clock.wise" = FALSE)
circos.initialize(factors = factors, xlim = c(0, 10))

circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.1, bg.border = NA, bg.col = "#E41A1C", panel.fun = function(x, y) {
    xlim = get.cell.meta.data("xlim")
    ylim = get.cell.meta.data("ylim")
    cell.xlim = get.cell.meta.data("cell.xlim")
    cell.ylim = get.cell.meta.data("cell.ylim")
    circos.rect(xlim[1], ylim[1], xlim[2], ylim[2], col = "#377EB8", border = "black", lwd = 1)
    circos.rect(cell.xlim[1], cell.ylim[2], cell.xlim[2], cell.ylim[2]+(cell.ylim[2]-cell.ylim[1])/2, col = "#984EA3", border = NA)
    circos.rect(cell.xlim[1], cell.ylim[1]-(cell.ylim[2]-cell.ylim[1])/2, cell.xlim[2], cell.ylim[1], col = "#984EA3", border = NA)
    circos.lines(0:10, runif(11)*10)
    circos.rect(cell.xlim[1], cell.ylim[1], cell.xlim[2], cell.ylim[2], lwd = 2)
})
circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.3, bg.border = NA, bg.col = "#E41A1C", panel.fun = function(x, y) {
    xlim = get.cell.meta.data("xlim")
    ylim = get.cell.meta.data("ylim")
    cell.xlim = get.cell.meta.data("cell.xlim")
    cell.ylim = get.cell.meta.data("cell.ylim")
    circos.rect(xlim[1], ylim[1], xlim[2], ylim[2], col = "#377EB8", border = "black", lwd = 1)
    circos.rect(cell.xlim[1], cell.ylim[2], cell.xlim[2], cell.ylim[2]+(cell.ylim[2]-cell.ylim[1])/6, col = "#984EA3", border = NA)
    circos.rect(cell.xlim[1], cell.ylim[1]-(cell.ylim[2]-cell.ylim[1])/6, cell.xlim[2], cell.ylim[1], col = "#984EA3", border = NA)
    circos.lines(0:10, runif(11)*10)
    circos.rect(cell.xlim[1], cell.ylim[1], cell.xlim[2], cell.ylim[2], lwd = 2)
})
circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.1, bg.border = NA, bg.col = "#E41A1C", panel.fun = function(x, y) {
    xlim = get.cell.meta.data("xlim")
    ylim = get.cell.meta.data("ylim")
    cell.xlim = get.cell.meta.data("cell.xlim")
    cell.ylim = get.cell.meta.data("cell.ylim")
    circos.rect(xlim[1], ylim[1], xlim[2], ylim[2], col = "#377EB8", border = "black", lwd = 1)
    circos.rect(cell.xlim[1], cell.ylim[2], cell.xlim[2], cell.ylim[2]+(cell.ylim[2]-cell.ylim[1])/2, col = "#984EA3", border = NA)
    circos.rect(cell.xlim[1], cell.ylim[1]-(cell.ylim[2]-cell.ylim[1])/2, cell.xlim[2], cell.ylim[1], col = "#984EA3", border = NA)
    circos.lines(0:10, runif(11)*10)
    circos.rect(cell.xlim[1], cell.ylim[1], cell.xlim[2], cell.ylim[2], lwd = 2)
})

x = seq(0, 1, length = 1000)
y = sqrt(1^2 - x^2)
lines(x, y, lty = 3, lwd = 2)

x = seq(0, 0.8, length = 1000)
y = sqrt(0.8^2 - x^2)
lines(x, y, lty = 3, lwd = 2)

x = seq(0, 0.4, length = 1000)
y = sqrt(0.4^2 - x^2)
lines(x, y, lty = 3, lwd = 2)

x = seq(0, 0.2, length = 1000)
y = sqrt(0.2^2 - x^2)
lines(x, y, lty = 3, lwd = 2)

draw.sector(center = c(0, 0), start = 17, end = 20, rou1 = 1, rou2 = 0.2, col = "#4DAF4A")
draw.sector(center = c(0, 0), start = 62, end = 65, rou1 = 1, rou2 = 0.2, col = "#4DAF4A")

circos.text(5, 5, "plotting region", sector.index = "a", track.index = 2)
circos.text(5, 10.5, "cell.padding[3]", sector.index = "a", track.index = 2)
circos.text(5, -0.5, "cell.padding[1]", sector.index = "a", track.index = 2)
circos.text(-0.5, 5, "cell.padding[2]", direction = "vertical_right", sector.index = "a", track.index = 2)
circos.text(10.5, 5, "cell.padding[4]", direction = "vertical_right", sector.index = "a", track.index = 2)
circos.text(5, -2, "track.margin[1]", sector.index = "a", track.index = 2)
circos.text(5, 12, "track.margin[2]", sector.index = "a", track.index = 2)
circos.text(-1.5, 5, "gap.degree", direction = "vertical_right", sector.index = "a", track.index = 2)
circos.text(11.5, 5, "gap.degree", direction = "vertical_right", sector.index = "a", track.index = 2)
circos.clear()
@

\begin{figure}
\begin{center}
<<label=figregion, fig = TRUE, echo = FALSE, results=hide>>=
<<figregion>>
@
\caption{Regions for a cell}
\label{fig:region}
\end{center}
\end{figure}

<<label=figdirection, echo=FALSE, eval=FALSE>>=
par(mfrow = c(2, 1))
par(mar = c(1, 1, 1, 1))
factors = letters[1:8]
circos.par("track.margin" = c(0.1, 0.1), "clock.wise" = FALSE, start.degree = 30,
    "gap.degree" = rep(c(2, 10), 4))
circos.initialize(factors = factors, xlim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.4, panel.fun = function(x, y) {
    circos.text(5, 5, get.cell.meta.data("sector.index"))
    xlim = get.cell.meta.data("xlim")
    ylim = get.cell.meta.data("ylim")
    circos.lines(xlim, c(0, 0))
    circos.lines(c(9, 10), c(0.5, 0))
    circos.lines(c(9, 10), c(-0.5, 0))
    circos.lines(c(0, 0), xlim)
    circos.lines(c(0.5, 0), c(9, 10))
    circos.lines(c(-0.5, 0), c(9, 10))
})
circos.clear()

x = seq(-0.7, 0.7, length = 100)
d = cbind(x, sqrt(1 - x^2))
lines(d)
arrows(d[2,1], d[2,2], d[1,1], d[1,2])

x = seq(-0.7, 0.7, length = 100)
d = cbind(x, -sqrt(1 - x^2))
lines(d)
arrows(d[99,1], d[99,2], d[100,1], d[100,2])

text(0, 0, 'circos.par("clock.wise" = FALSE,\nstart.degree = 30)', cex = 0.6)

par(mar = c(1, 1, 1, 1))
factors = letters[1:8]
circos.par("track.margin" = c(0.1, 0.1), "clock.wise" = TRUE, start.degree = -30,
    "gap.degree" = rep(c(2, 10), 4))
circos.initialize(factors = factors, xlim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.4, panel.fun = function(x, y) {
    circos.text(5, 5, get.cell.meta.data("sector.index"))
    xlim = get.cell.meta.data("xlim")
    ylim = get.cell.meta.data("ylim")
    circos.lines(xlim, c(0, 0))
    circos.lines(c(9, 10), c(0.5, 0))
    circos.lines(c(9, 10), c(-0.5, 0))
    circos.lines(c(0, 0), xlim)
    circos.lines(c(0.5, 0), c(9, 10))
    circos.lines(c(-0.5, 0), c(9, 10))
})
circos.clear()

x = seq(-0.7, 0.7, length = 100)
d = cbind(x, sqrt(1 - x^2))
lines(d)
arrows(d[99,1], d[99,2], d[100,1], d[100,2])


x = seq(-0.7, 0.7, length = 100)
d = cbind(x, -sqrt(1 - x^2))
lines(d)
arrows(d[2,1], d[2,2], d[1,1], d[1,2])
text(0, 0, 'circos.par("clock.wise" = TRUE,\nstart.degree = -30)', cex = 0.6)
@

\begin{figure}
\begin{center}
<<label=figdirection, fig = TRUE, echo = FALSE, width=4, height=8, results=hide>>=
<<figdirection>>
@
\end{center}
\caption{Sector directions. Sector orders are {\tt a}, ..., {\tt h}.}
\label{fig:direction}
\end{figure}


\subsection{Circos parameters}
Some basic parameters for the circos layout can be set through {\tt circos.par}. The paramters
are as follows, note some parameters can only be assigned before the initialization of the circos layout.

\begin{itemize}
    \item {\tt start.degree}: The starting degree at which the circle begin to draw. Note this degree is measured 
          in the standard polar coordinate which means it is always reverse clockwise. See figure \ref{fig:direction}.
    \item {\tt gap.degree}: Gap between two neighbour sectors. It can be a single value which means all gaps sharing same
          degree, or a vector which has same length as levels of the factors. See figure \ref{fig:direction} and figure \ref{fig:region}.
    \item {\tt track.margin}: Like {\tt margin} in Cascading Style Sheets (CSS), it is the blank area
          out of the plotting region, also outside of the borders. Since left and right margin are controlled
          by {\tt gap.degree}, only bottom and top margin need to be set. The value for the {\tt track.margin}
          is the percentage according to the radius of the unit circle. See figure \ref{fig:region}.
    \item {\tt cell.padding}: Padding of the cell. Like {\tt padding} in Cascading Style Sheets
          (CSS), it is the blank area around the plotting regions, but within the borders.
          The paramter has four values, which controls the bottom, left, top and right padding
          respectively. The four values are all percentages in which the first and the third padding
          values are the percentages according to the range of values on y-axis and the second and
          fourth values are the percentages according to the range of values on x-axis. See figure \ref{fig:region}.
    \item {\tt unit.circle.segments}: Since curves are simulated by a series of straight lines,
          this parameter controls the amount of segments to represent a curve. The minimal length
          of the line segment is the length of the unit circle ({\tt 2*pi}) divided by {\tt unit.circle.segments}.     
    \item {\tt default.track.height}: The default height of tracks. It is the percentage according to the radius
          of the unit circle ({\tt 1}). The height includes the top and bottom cell paddings but not the margins.
    \item {\tt points.overflow.warning}: Since each cell is in fact not a real plotting region but only
          an ordinary rectangle, it does not eliminate points that are plotted out of
          the region. So if some points are out of the plotting region, by default, the 
          package would continue drawing the points and print warnings. But in some 
          circumstances, draw something out of the plotting region is useful, such as draw
          some legend or text. Set this value to {\tt FALSE} to turn off the warnings.
    \item {\tt canvas.xlim}: The coordinate for the canvas. The package is forced to draw unit circle, so
          the {\tt xlim} and {\tt ylim} for the canvas would be {\tt c(-1, 1)}. However, you can set it to a more broad
          interval if you want to draw other things out of the circle. By choose proper
          {\tt canvas.xlim} and {\tt canvas.ylim}, you can draw part of the circle. E.g. setting
          {\tt canvas.xlim} to {\tt c(0, 1)} and {\tt canvas.ylim} to {\tt c(0, 1)} would only draw
          circle in the region of {\tt (0, pi/2)}. 
    \item {\tt canvas.ylim}: The coordinate for the canvas.
    \item {\tt clock.wise}: The order of drawing sectors. Default is {\tt TRUE} which means clockwise (figure \ref{fig:direction}).
          But note that inside each cell, the direction of x-axis is always clockwise and direction of y-axis is always from inside to outside in the circle.
\end{itemize}

Parameters related to the allocation of sectors cannot be changed after the initialization of the circos layout.
So {\tt start.degree}, {\tt gap.degree}, {\tt canvas.xlim}, {\tt canvas.ylim} and {\tt clock.wise} can only
be modified before {\tt circos.initialize}. The second and the fourth element of {\tt cell.padding} (left and right paddings) can not
be modified either or the modification is effectiveless.

<<label=figlines, echo=FALSE, eval=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1), cex = 0.8)
factors = letters[1:8]
circos.par(points.overflow.warning = FALSE)
circos.initialize(factors = factors, xlim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.5)
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "a")
circos.text(5, 9, "type = 'l'", sector.index = "a", direction = "default2")
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "b", type = "o")
circos.text(5, 9, "type = 'o'", sector.index = "b", direction = "default2")
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "c", type = "h")
circos.text(5, 9, "type = 'h'", sector.index = "c", direction = "default2")
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "d", type = "s")
circos.text(5, 9, "type = 's'", sector.index = "d", direction = "default2")
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "e", area = TRUE)
circos.text(5, 9, "type = 'l', area = TRUE", sector.index = "e")
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "f", type = "o", area = TRUE)
circos.text(5, 9, "type = 'o', area = TRUE", sector.index = "f")
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "g", type = "s", area = TRUE)
circos.text(5, 9, "type = 's', area = TRUE", sector.index = "g")
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "h", area = TRUE, area.baseline = "top")
circos.text(5, 1, "type = 'l', area = TRUE\narea.baseline = 'top'", sector.index = "h")
circos.clear()
par(cex = 1)
@

\begin{figure}
\begin{center}
<<label=figlines, fig = TRUE, echo = FALSE, results=hide>>=
<<figlines>>
@
\end{center}
\caption{Line style settings}
\label{fig:lines}
\end{figure}

\subsection{Points}
Drawing points by {\tt circos.points} is similar as {\tt points} function. Possible usage is:

\begin{Schunk}
\begin{Sinput}
> circos.points(x, y)
> circos.points(x, y, sector.index, track.index)
> circos.points(x, y, pch, col, cex)
\end{Sinput}
\end{Schunk}

Since {\tt circos.points} is a low-level function, it can only be applied to those
cells which have been created. If {\tt sector.index} or {\tt track.index} is not
specified, it would use the 'current' index for sector and track which would be 
defined by the nearest {\tt circos.trackPlotRegion} or {\tt circos.updatePlotRegion}.

{\tt circos.trackPoints} can draw points in the whole cells on a same track.
However, it is the same if you use {\tt circos.points} in a {\tt for} loop.


\subsection{Lines}
Parameters for drawing lines by {\tt circos.lines} are similar to {\tt lines} function, 
as illustrated in figure \ref{fig:lines}. One additional feature is that the areas under/above lines can be 
specified by {\tt area} argument which can help you identifying the direction of y-axis. Also the base line for the area can be set by {\tt area.baseline}.
{\tt area.baseline} can be pre-defined string of {\tt bottom} or {\tt top}, or numeric values.

Straight lines will be transformed to curves when mapping to the circos layout. Normally, 
curves can be approximated by a series of segmentations of straight lines. With more segmentations,
there would be better approximations, but with larger size if you generate the graph as pdf format, especially
for huge genomic data. So, in this package, the number of the segmentation can be controlled by {\tt circos.par("unit.circle.segments")}.
The length of minimal segment is the length of the unit circle divided by 
{\tt circos.par("unit.circle.segments")}. If you do not want such curve-transformations (such as
radical lines), you can set {\tt straight} argument to {\tt TRUE}. 

Possible usage for {\tt circos.lines} is:

\begin{Schunk}
\begin{Sinput}
> circos.lines(x, y)
> circos.lines(x, y, sector.index, track.index)
> circos.lines(x, y, col, lwd, lty, type, straight)
> circos.lines(x, y, col, area, area.baseline, border)
\end{Sinput}
\end{Schunk}

Similar as {\tt circos.points}, if no {\tt sector.index} or {\tt track.index} is
specified, 'current' index would be used. Also, there is a {\tt circos.trackLines}
which is identical to {\tt circos.lines} in a {\tt for} loop.

<<label=figtext, echo=FALSE, eval=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
factors = letters[1:4]
circos.par(points.overflow.warning = FALSE)
circos.initialize(factors = factors, xlim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.5, panel.fun = function(x, y) {
    circos.text(3, 9, "default", direction = "default")
    circos.text(7, 9, "default2", direction = "default2")
    circos.text(0, 5, "vertical_left", direction = "vertical_left")
    circos.text(10, 5, "vertical_right", direction = "vertical_right")
    circos.text(5, 5, "horizontal", direction = "horizontal")
    circos.text(5, 1, "arc_arc_arc_arc_arc", direction = "arc")
})
circos.clear()
@

\begin{figure}
\begin{center}
<<label=figtext, fig = TRUE, echo = FALSE, results=hide>>=
<<figtext>>
@
\end{center}
\caption{Text direction settings}
\label{fig:text}
\end{figure}


\subsection{Text}
Only the direction of text by {\tt circos.text} should be noted, as illustrated in figure \ref{fig:text}.
Only six directions of text are allowed which are pre-defined in {\tt c("default", "default2", "vertical\_left", "vertical\_right", "horizontal", "arc")}.

\begin{itemize}
    \item {\tt default}: direction of the tangent, facing bottom at $90^\circ$ position.
    \item {\tt default2}: direction of the tangent, facing bottom at $-90^\circ$ position.
    \item {\tt vertical\_left}: direction of radius, facing left at $90^\circ$ position.
    \item {\tt vertical\_right}: direction of radius, facing right at $90^\circ$ position.
    \item {\tt horizontal}: horizontal direction in the canvas coordinate.
    \item {\tt arc}: direction of the arc (not straight).
\end{itemize}

{\tt srt} in {\tt text} has been degenerated as {\tt direction} in {\tt circos.text} which only support only six types of rotation.
But {\tt adj} argument is still applicable in {\tt circos.text}.

Possible usage for {\tt circos.text} is:

\begin{Schunk}
\begin{Sinput}
> circos.text(x, y, labels)
> circos.text(x, y, labels, sector.index, track.index)
> circos.text(x, y, labels, direction, adj, cex, col, font)
\end{Sinput}
\end{Schunk}

There is also a {\tt circos.trackText} in the package.

\subsection{Rectangle}
If you imagin the plotting region in a cell as Cartesian coordinate, then it draws rectangles.
In the polar coordinate, the up and bottom edge become two arcs. Usage is similar
as {\tt rect}:

\begin{Schunk}
\begin{Sinput}
> circos.rect(xleft, ybottom, xright, ytop)
> circos.rect(xleft, ybottom, xright, ytop, sector.index, track.index)
> circos.rect(xleft, ybottom, xright, ytop, col, border, lty, lwd)
\end{Sinput}
\end{Schunk}

\subsection{Polygon}
Similar as {\tt circos.rect} and {\tt polygon}, it draws a polygon through a series
of points in a cell:

\begin{Schunk}
\begin{Sinput}
> circos.polygon(x, y)
> circos.polygon(x, y, sector.index, track.index)
> circos.polygon(x, y, col, border, lty, lwd)
\end{Sinput}
\end{Schunk}

In figure \ref{fig:errorline}, the area of standard deviation of the smoothed line
is drawn by {\tt circos.polygon}.

\begin{figure}
\begin{center}
<<label=figerrorline, fig = TRUE, echo = FALSE, results=hide>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
factors = letters[1:4]
circos.initialize(factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(-3, 3), track.height = 0.4, panel.fun = function(x, y) {
    x1 = runif(20)
    y1 = x1 + rnorm(20)
    or = order(x1)
    x1 = x1[or]
    y1 = y1[or]
    loess.fit = loess(y1 ~ x1)
    loess.predict = predict(loess.fit, x1, se = TRUE)
    d1 = c(x1, rev(x1))
    d2 = c(loess.predict$fit + loess.predict$se.fit, rev(loess.predict$fit - loess.predict$se.fit))
    circos.polygon(d1, d2, col = "#CCCCCC", border = NA)
    circos.points(x1, y1, cex = 0.5)
    circos.lines(x1, loess.predict$fit)
})
circos.clear()
@
\end{center}
\caption{Area of standard deviation of the smooth line}
\label{fig:errorline}
\end{figure}


<<label=figaxis, echo=FALSE, eval=FALSE>>=
library(circlize)

par(mar = c(1, 1, 1, 1))
factors = letters[1:8]
circos.par(points.overflow.warning = FALSE)
circos.initialize(factors = factors, xlim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.1, bg.border = NA, panel.fun = function(x, y) {
    circos.text(5, 10, get.cell.meta.data("sector.index"))
})

circos.trackPlotRegion(factors = factors, ylim = c(0, 10))
circos.axis(sector.index = "a")
circos.axis(sector.index = "b", direction = "inside", labels.direction = "default2")
circos.axis(sector.index = "c", h = "bottom")
circos.axis(sector.index = "d", h = "bottom", direction = "inside", labels.direction = "vertical_left")
circos.axis(sector.index = "e", h = 5, major.at = c(1, 3, 5, 7, 9))
circos.axis(sector.index = "f", h = 5, major.at = c(1, 3, 5, 7, 9), labels = c("a", "c", "e", "g", "f"), minor.ticks = 0)
circos.axis(sector.index = "g", h = 5, major.at = c(1, 3, 5, 7, 9), labels = c("a1", "c1", "e1", "g1", "f1"), major.tick = FALSE, labels.direction = "vertical_left")
circos.axis(sector.index = "h", h = 2, major.at = c(1, 3, 5, 7, 9), labels = c("a1", "c1", "e1", "g1", "f1"), major.tick.percentage = 0.3, labels.away.percentage = 0.2, minor.ticks = 2, labels.direction = "vertical_right")
circos.clear()
@

\begin{figure}
\begin{center}
<<label=figaxis, fig = TRUE, echo = FALSE, results=hide>>=
<<figaxis>>
@
\end{center}
\caption{Axis settings}
\label{fig:axis}
\end{figure}

\subsection{Axis}
Because there may be no space to draw y-axis, only drawing x-axis for each cell is supported by {\tt circos.axis}, as illustrated in figure \ref{fig:axis}.
A lot of styles for axis can be set such as the position and length of major ticks, the number of minor ticks,
the position and direction of the axis labels and the position of the x-axis. Note the adjustment of label strings is defined internally according
to differnet label directions to ensure the start/end position of the string is located near the major tick.

In figure \ref{fig:axis}, axis styles in different sectors are :

\begin{itemize}
  \item a: Major ticks are calculated automatically, other settings are default.
  \item b: Ticks are pointing to inside of the circle, facing of tick labels is set to {\tt default2}.
  \item c: Position of x-axis is {\tt bottom} of the cell.
  \item d: Ticks are pointing to inside of the circle, facing of tick labels is set to {\tt vertical\_left}.
  \item e: Self-defined major ticks.
  \item f: Self-defined major ticks and tick labels, no minor ticks.
  \item g: No ticks for both major and minor ones, facing of tick labels is set to {\tt vertical\_left}.
  \item h: Number of minor ticks between two major ticks is set to 2. Length of ticks is longer and axis labels are more away from ticks. Facing of tick labels is set to {\tt vertical\_right}.
\end{itemize}



For {\tt circos.axis}, possible usage is as follows. {\tt h} can be pre-defined string of {\tt bottom} or {\tt top}, or numeric values. 

\begin{Schunk}
\begin{Sinput}
> circos.axis(h)
> circos.axis(h, sector.index, track.index)
> circos.axis(h, major.at, labels, major.tick)
> circos.axis(h, major.at, labels, major.tick, labels.font, labels.cex,
+             labels.direction, labels.away.percentage)
> circos.axis(h, major.at, labels, major.tick, minor.ticks,
+             major.tick.percentage, lwd)
\end{Sinput}
\end{Schunk}

<<label=figlink, echo=FALSE, eval=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1), mfrow = c(2, 1))
factors = letters[1:8]
circos.par(points.overflow.warning = FALSE)
circos.initialize(factors = factors, xlim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 1), bg.col = "grey", bg.border = NA, track.height = 0.05)

circos.link("a", 5, "c", 5)
circos.link("b", 5, "d", c(4, 6))
circos.link("a", c(2, 3), "f", c(4, 6))

circos.clear()


degree.minus = function(to, from, min.zero = TRUE) {
    if(min.zero) {
        return((to - from) %% 360)
    } else {
        if((to - from) %% 360 == 0) {
            return(360)
        } else {
            return((to - from) %% 360)
        }
    }
}
rotate.parabola = function(theta1, theta2, rou1, rou2 = rou1, theta = (theta1+theta2)/2, 
    rou = rou1 * abs(cos(degree.minus(theta1, theta2)/2/180*pi))*rou.ratio, rou.ratio = 0.5,
    n = 1001) {
    
    while(theta2 < theta1) {
        theta2 = theta2 + 360
    }
    
    delta_theta = degree.minus(theta2, theta1)
    
    flag = 0
    if(delta_theta > 180) {
        theta = theta + 180
        flag = 1
    }
    
    # y^2 = kx, y = +-sqrt(kx)
    b = rou1 * abs(sin(degree.minus(theta2, theta1)/2/180*pi))
    a = rou1 * abs(cos(degree.minus(theta2, theta1)/2/180*pi)) - rou
    k = b^2/a
    
    if(n %% 2 == 0) {
        n = n + 1
    }
    n.half = (n - 1) / 2
    x = numeric(n)
    y = numeric(n)
    x = c(n.half:1/n.half, 0, 1:n.half/n.half)*a
    y[1:n.half] = sqrt(k*x[1:n.half])
    y[n.half + 1] = 0
    y[1:n.half + n.half + 1] = -sqrt(k*x[1:n.half + n.half + 1])
    
    alpha = numeric(n)
    
    alpha[1:n.half] = atan(y[1:n.half]/x[1:n.half])*180/pi
    alpha[1:n.half + n.half + 1] = atan(y[1:n.half + n.half + 1]/x[1:n.half + n.half + 1])*180/pi
    alpha[n.half + 1] = 90
    
    d = sqrt(x^2 + y^2)
    x = d*cos((alpha + theta)/180*pi)
    y = d*sin((alpha + theta)/180*pi)
    
    center.x = rou*cos(theta/180*pi)
    center.y = rou*sin(theta/180*pi)
    
    x = x + center.x
    y = y + center.y
    
    if(!flag) {
        x = rev(x)
        y = rev(y)
    }

    return(cbind(x, y))
}

polar2Cartesian = function(d) {
    theta = d[, 1]/360 * 2 *pi
    rou = d[, 2]
    x = rou * cos(theta)
    y = rou * sin(theta)
    return(cbind(x, y))
}
par(mar = c(1, 1, 1, 1))
plot(c(-1, 1), c(-1, 1), axes = FALSE, ann = FALSE ,type = "n")
draw.sector(center = c(0, 0), start.degree = 0, end.degree = 360, rou1 = 1, col = "white", border = "black")
d= rotate.parabola(theta1 = 270, theta2 = 330, rou1 = 1, rou.ratio = 0.5)
lines(rbind(d, d[1, ]))
lines(c(cos(300/180*pi), cos(120/180*pi)), c(sin(300/180*pi), sin(120/180*pi)))
points(0, 0, pch = 16)
lines(c(0, sqrt(3)/4)+0.01, c(0, -3/4)+0.01, lwd = 4, col = "red")
lines(c(0, sqrt(3)/4/2)-0.01, c(0, -3/4/2)-0.01, lwd = 4, col = "blue")
@

\begin{figure}
\begin{center}
<<label=figlink, fig = TRUE, echo = FALSE, height=8, width=4, results=hide>>=
<<figlink>>
@
\end{center}
\caption{Drawing links}
\label{fig:link}
\end{figure}


\subsection{Links}
Links can be drawn by {\tt circos.link} from points and intervals (figure \ref{fig:link}, top). If both ends are points, then the link is represented
as a line. If one of the ends is an interval, the link would be a belt. The link is in fact a quadratic curve. Links do not hold any position of track.
So links can be overlapping with tracks.

The position of the 'root' of the link is controlled by {\tt rou} argument. By default, it is the end position of the most recently created track.
So normally, you don't need to care about this setting.

The height of the link can be controlled by {\tt top.ratio} argument in {\tt circos.link} which is the ratio between the length of blue line and 
the red line (maximum of the link height), see figure \ref{fig:link}, bottom. The default height looks well from my view point, so you don't need to change this value.

Possible usage for {\tt circos.link} is:

\begin{Schunk}
\begin{Sinput}
> circos.link(sector.index1, 0, sector.index2, 0)
> circos.link(sector.index1, c(0, 1), sector.index2, 0)
> circos.link(sector.index1, c(0, 1), sector.index2, c(1, 2))
> circos.link(sector.index1, 0, sector.index2, 0, rou, top.ratio)
> circos.link(sector.index1, c(0, 1), sector.index2, 0,
+             col, lwd, lty, border)
\end{Sinput}
\end{Schunk}

\subsection{The {\tt panel.fun} argument in {\tt circos.trackPlotRegion}}
{\tt panel.fun} argument in {\tt circos.trackPlotRegion} is useful to apply plottings as soon as the cell has been created. This self-defined
function need two arguments {\tt x} and {\tt y} which are data points that belong to this cell. The value for such values are automatically extracted from {\tt x} and {\tt y}
in {\tt circos.trackPlotRegion} function according to the category argument {\tt factors}. In the following example, {\tt x} in category {\tt a} in {\tt panel.fun}
would be {\tt 1:3} and {\tt y} values are {\tt 5:3}. If {\tt x} or {\tt y} in {\tt circos.trackPlotRegion} is {\tt NULL}, then {\tt x} or {\tt y} inside
{\tt panel.fun} is also {\tt NULL}.

\begin{Schunk}
\begin{Sinput}
> factors = c("a", "a", "a", "b", "b")
> x = 1:5
> y = 5:1
> circos.trackPlotRegion(factors = factors, x = x, y = y,
+     panel.fun = function(x, y) {
+         circos.points(x, y)
+     })
\end{Sinput}
\end{Schunk}

In {\tt panel.fun}, one thing important is that if you use any low-level circos functions, you don't need to specify {\tt sector.index} and {\tt track.index} explicitly.
Remember that when applying {\tt circos.trackPlotRegion}, cells in the track are created one after one. When a cell is created, the package would set the sector index
and track index of the cell as the 'current' index for sector and track. When the cell is created, {\tt panel.fun} would be exceeded afterward immediately. Without specifying
{\tt sector.index} and {\tt track.index}, the 'current' one would be used.

Inside {\tt panel.fun}, more information of the 'current' cell would be obtained through
{\tt get.cell.meta.data}. Also this funciton takes the 'current' sector and 'current' track by default,
Explaination of {\tt get.cell.meta.data} can be found in following section.


\subsection{High level plotting functions}
With those low-level function such as {\tt circos.points}, {\tt circos.lines},
more high-level functions can be easily written. The package provides a high-level 
function {\tt circos.trackHist} which draws histograms or the density
distributions of data (figure \ref{fig:hist}). So users would know how to implement other
high-level function to support graphs such as barplot, heatmap, ... accroding to the source code of {\tt circos.trackHist}.

In figure \ref{fig:hist}, the first track is histograms in which all the {\tt ylim} are the same.
The second track is histograms in which {\tt force.ylim} is {\tt FALSE}.
The third and the fourth tracks are density distributions in which ylims
are forced same or not.


<<label=fighist, echo=FALSE, eval=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
x = rnorm(2600)
factors = sample(letters, 2600, replace = TRUE)
circos.initialize(factors = factors, x = x)
circos.trackHist(factors = factors, x = x, track.height = 0.1, col = "#999999", border = "#999999")
circos.trackHist(factors = factors, x = x, force.ylim = FALSE, track.height = 0.1, col = "#999999", border = "#999999")
circos.trackHist(factors = factors, x = x, draw.density = TRUE, track.height = 0.1, col = "#999999", border = "#999999")
circos.trackHist(factors = factors, x = x, draw.density = TRUE, force.ylim = FALSE, track.height = 0.1, col = "#999999", border = "#999999")

circos.clear()

@

\begin{figure}
\begin{center}
<<label=fighist, fig = TRUE, echo = FALSE, results=hide>>=
<<fighist>>
@
\end{center}
\caption{Histograms}
\label{fig:hist}
\end{figure}

In figure \ref{fig:heatmap} you would see heatmaps and cluster dendrograms in a circos layout. Heatmaps are
series of grids which can be drawn by {\tt circos.rect}. Dendrograms are series of lines which can be drawn
by {\tt circos.lines}. However, x-values for heatmaps and dendrograms are not really x-values but just index for
the grid/leaf (i.e., 1, 2, ... for grid/leaf 1, 2, ...), so it would be hard (or not proper) to make them
as general functions for circos plotting. Thus we do not provide such {\tt circos.heatmap} or {\tt circos.dendrogram}
in the package for public use. Anyway, we still wrote a not-full-functional {\tt circos.dendrogram} in the
source code of this vignette. If you want to draw heatmap or dendrogram (like evolution tree) by your own, this may be 
helpful for you. (type {\tt help(package = "circlize")} in your R terminal, click link of ``Overview of user guides and package vignettes"
in the browser, click link of ``R code" corresponding to ``circlize::circlize", and search for code 
chunk of ``figheatmap".)

\begin{figure}
\begin{center}
<<label=figheatmap, fig = TRUE, echo = FALSE, results=hide>>=

circos.dendrogram = function(dend, maxy) {
  labels = as.character(labels(dend))
    x = seq_along(labels) - 0.5
    names(x) = labels

    is.leaf = function(object) (is.logical(L <- attr(object, "leaf"))) && L

    draw.d = function(dend, maxy) {
        leaf = attr(dend, "leaf")
        d1 = dend[[1]]
        d2 = dend[[2]]
        height = attr(dend, 'height')
        midpoint = attr(dend, 'midpoint')

        if(is.leaf(d1)) {
            x1 = x[as.character(attr(d1, "label"))]
        } else {
            x1 = attr(d1, "midpoint") + x[as.character(labels(d1))[1]]
        }
        y1 = attr(d1, "height")

        if(is.leaf(d2)) {
            x2 = x[as.character(attr(d2, "label"))]
        } else {
            x2 = attr(d2, "midpoint") + x[as.character(labels(d2))[1]]
        }
        y2 = attr(d2, "height")

        circos.lines(c(x1, x1), maxy - c(y1, height), straight = TRUE)
        circos.lines(c(x1, x2), maxy - c(height, height))
        circos.lines(c(x2, x2), maxy - c(y2, height), straight = TRUE)

        if(!is.leaf(d1)) {
            draw.d(d1, maxy)
        }
        if(!is.leaf(d2)) {
            draw.d(d2, maxy)
        }
    }
    
    draw.d(dend, maxy)
}


get_color = function(x,
                     colors = c("green", "black", "red"), # color points
                     fc = c(-5, 0, 5),                    # data points
                     gradient = function(x)x) {

    # change colors represented as strings to RGB space
    col_section = sapply(colors, function(x) as.vector(col2rgb(x)))
    col_section = t(col_section)

    x[x >= max(fc)] = max(fc)
    x[x <= min(fc)] = min(fc)

    fc = sign(fc)*gradient(abs(fc))

    color = character(length(x))
    for(i in 1:length(x)) {
        # NA values, grey color
        if(!is.numeric(x[i])) {
            color[i] = rgb(128, 128, 128, maxColorValue = 255)
            next
        }
        value = sign(x[i])*(gradient(abs(x[i])))

        # find which interval the value belongs to
        interval = which(fc >= x[i])[1]
        if(length(interval) == 0) {
            interval = length(interval)
        }
        if(interval == 1) {
            interval = 2
        }

        # linear interpolation
        col_num = (value - fc[interval])*(col_section[interval, ] - col_section[interval - 1, ]) / (fc[interval] - fc[interval - 1]) + col_section[interval, ]

        col_num = ifelse(col_num > 255, 255, col_num)
        col_num = ifelse(col_num < 0, 0, col_num)

        color[i] = rgb(col_num[1], col_num[2], col_num[3], maxColorValue = 255)
    }

    return(color)
}

library(circlize)
mat = matrix(rnorm(100*10), nrow = 10, ncol = 100)
factors = rep(letters[1:2], 50)
par(mar = c(1, 1, 1, 1))
circos.par(cell.padding = c(0, 0, 0, 0), gap.degree = 5)
circos.initialize(factors, xlim = c(0, 50))
maxy = 0
circos.trackPlotRegion(ylim = c(0, 10), bg.border = NA, panel.fun = function(x, y) {
  sector.index = get.cell.meta.data("sector.index")
    m = mat[, factors == sector.index]
    
    dend.col = as.dendrogram(hclust(dist(t(m))))

    maxy = ifelse(maxy > attr(dend.col, "height"), maxy, attr(dend.col, "height"))
    assign("maxy", maxy, envir = .GlobalEnv)

    m2 = m[, labels(dend.col)]
    nr = nrow(m2)
    nc = ncol(m2)
    for(i in 1:nr) {
        for(j in 1:nc) {
            circos.rect(j-1, nr-i, j, nr-i+1, border = get_color(m2[i, j], fc = c(-2, 0, 2)), col = get_color(m2[i, j], fc = c(-2, 0, 2)))
        }
    }
    
})
circos.trackPlotRegion(ylim = c(0, maxy), bg.border = NA, track.height = 0.3, panel.fun = function(x, y) {
    sector.index = get.cell.meta.data("sector.index")
    m = mat[, factors == sector.index]
    
    dend.col = as.dendrogram(hclust(dist(t(m))))

    circos.dendrogram(dend.col, maxy)
    
})
circos.clear()
@
\end{center}
\caption{Heatmap with clustering}
\label{fig:heatmap}
\end{figure}

\subsection{Other functions}
{\tt draw.sector} can be used to draw sectors or part of a ring. This is useful if you want to hightlight some part of your circos plot.
As you can think, this function needs arguments of the position of circle center, the start degree and the end degree for sectors, 
and radius for two edges (or one edge) which may be the up or bottom border of a cell. These information can be obtained by {\tt get.cell.meta.data}. E.g. the start degree
and end degree can be obtained through {\tt cell.start.degree} and {\tt cell.end.degree}, and the position of the top border and bottom
border on the circle radius can be obtained through {\tt cell.top.radius} and {\tt cell.bottom.radius}. An example is as follows and see figure \ref{fig:sectorhighlight}
in which different colors correspond to different regions that need to be highlighted.

Remember the color should be semi-transparent in the highlighted area. Usage for {\tt draw.sector} is:

\begin{Schunk}
\begin{Sinput}
> draw.sector(center, start.degree, end.degree, rou1)
> draw.sector(center, start.degree, end.degree, rou1, rou2)
> draw.sector(center, start.degree, end.degree, rou1, rou2,
+             col, border, lwd, lty)
\end{Sinput}
\end{Schunk}

{\tt get.cell.meta.cell} can provide detailed information for a cell. It needs the index
of sector and track as arguments. As usually, it would use 'current' index by default.

\begin{Schunk}
\begin{Sinput}
> get.cell.meta.data(name)
> get.cell.meta.data(name, sector.index, track.index)
\end{Sinput}
\end{Schunk}

Items that can be extracted by {\tt get.cell.meta.data} are:

\begin{itemize}
  \item {\tt sector.index}: The name (label) for the sector
  \item {\tt sector.numeric}.index: Numeric index for the sector
  \item {\tt track.index}: Numeric index for the track
  \item {\tt xlim}: Minimal and maximal values on the x-axis
  \item {\tt ylim}: Minimal and maximal values on the y-axis
  \item {\tt xrange}: Range of {\tt xlim}
  \item {\tt yrange}: Range of {\tt ylim}
  \item {\tt cell.xlim}: Minimal and maximal values on the x-axis extended by cell paddings
  \item {\tt cell.ylim}: Minimal and maximal values on the y-axis extended by cell paddings
  \item {\tt xplot}: Right and left border degree for the plotting region in the unit circle.
                        The first element corresponds to the start point of values on x-axis ({\tt cell.xlm[1]})
                        and the second element corresponds to the end point of values on x-axis ({\tt cell.xlim[2]})
                        Since x-axis in data coordinate in cells are always clockwise, {\tt xplot[1]} is larger
                        than {\tt xplot[2]}.
  \item {\tt yplot}: Bottom and top radius value for borders of the plotting region. It is the value
                        of radius of arc corresponding to inner border or outer border.
  \item {\tt cell.start.degree}: Same as {\tt xplot[1]}
  \item {\tt cell.end.degree}: Same as {\tt xplot[2]}
  \item {\tt cell.bottom.radius}: Same as {\tt yplot[1]}
  \item {\tt cell.top.radius}: Same as {\tt yplot[2]}
  \item {\tt track.margin}: Margins for the cell
  \item {\tt cell.padding}: Paddings for the cell
\end{itemize}

<<label=sectorhighlight, echo=FALSE, eval=FALSE>>=
library(circlize)

factors = letters[1:8]

par(mar = c(1, 1, 1, 1))
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1))

start.a1 = get.cell.meta.data("cell.start.degree", "a", 1)
end.a1 = get.cell.meta.data("cell.end.degree", "a", 1)
top.a1 = get.cell.meta.data("cell.top.radius", "a", 1)
draw.sector(start.degree = start.a1, end.degree = end.a1, rou1 = top.a1, border = NA, col = "#FF000040")

start.b2 = get.cell.meta.data("cell.start.degree", "b", 2)
end.b2 = get.cell.meta.data("cell.end.degree", "b", 2)
top.b2 = get.cell.meta.data("cell.top.radius", "b", 2)
draw.sector(start.degree = start.b2, end.degree = end.b2, rou1 = top.b2, border = NA, col = "#FF00FF40")

bottom.a1 = get.cell.meta.data("cell.bottom.radius", "a", 1)
draw.sector(start.degree = 0, end.degree = 360, rou1 = top.a1, rou2 = bottom.a1, border = NA, col = "#00FF0040")

start.c2 = get.cell.meta.data("cell.start.degree", "c", 2)
end.d2 = get.cell.meta.data("cell.end.degree", "d", 2)
top.c2 = get.cell.meta.data("cell.top.radius", "c", 2)
bottom.c2 = get.cell.meta.data("cell.bottom.radius", "c", 2)
draw.sector(start.degree = start.c2, end.degree = end.d2, rou1 = top.c2, rou2 = bottom.c2, border = NA, col = "#0000FF40")


start.g2 = get.cell.meta.data("cell.start.degree", "g", 2)
end.g2 = get.cell.meta.data("cell.end.degree", "g", 2)
top.g2 = get.cell.meta.data("cell.top.radius", "g", 2)
bottom.g3 = get.cell.meta.data("cell.bottom.radius", "g", 3)
draw.sector(start.degree = start.g2, end.degree = end.g2, rou1 = top.g2, rou2 = bottom.g3, border = NA, col = "#00FFFF40")


start.e2 = get.cell.meta.data("cell.start.degree", "e", 2)
end.f2 = get.cell.meta.data("cell.end.degree", "f", 2)
top.e2 = get.cell.meta.data("cell.top.radius", "e", 2)
bottom.e3 = get.cell.meta.data("cell.bottom.radius", "e", 3)
draw.sector(start.degree = start.e2, end.degree = end.f2, rou1 = top.e2, rou2 = bottom.e3, border = NA, col = "#FFFF0040")
show.index()
circos.clear()
@

\begin{figure}
\begin{center}
<<label=sectorhighlight, fig = TRUE, echo = FALSE, results=hide>>=
<<sectorhighlight>>
@
\end{center}
\caption{Hightlight sectors}
\label{fig:sectorhighlight}
\end{figure}


\subsection{Do not forget {\tt circos.clear}}
You should always call {\tt circos.clear} to complete the circos plottings. Because there are several
parameters for circos plot which can only be set before {\tt circos.initialize}. So before you draw the next
circos plot, you need to reset these parameters.

\section{Advanced plottings}

\subsection{Draw part of the circos layout}
{\tt canvas.xlim} and {\tt canvas.ylim} in {\tt circos.par} is useful to draw only part of circle. In the example,
only sectors between $0^\circ$ to $90^\circ$ are plotted (figure \ref{fig:part}). First, four sectors
with the same width are initialized. Then only the first sector is drawn with points and lines. From figure \ref{fig:part},
we in fact created the whole circle, but only a quarter of the circle is in the canvas region. Codes are as follows. 

<<eval=FALSE, echo=TRUE>>=
par(mar = c(1, 1, 1, 1))
circos.par("canvas.xlim" = c(0, 1), "canvas.ylim" = c(0, 1),
    "clock.wise" = FALSE, "gap.degree" = 0)
factors = letters[1:4]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(factors = factors, ylim = c(0, 1),
    bg.border = NA)
circos.updatePlotRegion(sector.index = "a", bg.border = "black")
x1 = runif(100)
y1 = runif(100)
circos.points(x1, y1, pch = 16, cex = 0.5)
circos.trackPlotRegion(factors = factors, ylim = c(0, 1),
    bg.border = NA)
circos.updatePlotRegion(sector.index = "a", bg.border = "black")
circos.lines(1:100/100, y1, pch = 16, cex = 0.5)
@


<<label=figpart, echo=FALSE, eval=FALSE>>=
library(circlize)
par(mfrow = c(2, 1))
par(mar = c(1, 1, 1, 1))
circos.par("clock.wise" = FALSE, "gap.degree" = 0)
factors = letters[1:4]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(factors = factors, ylim = c(0, 1))
circos.updatePlotRegion(sector.index = "a", bg.border = "black")
x1 = runif(100)
y1 = runif(100)
circos.points(x1, y1, pch = 16, cex = 0.5)
circos.trackPlotRegion(factors = factors, ylim = c(0, 1), bg.border = NA)
circos.updatePlotRegion(sector.index = "a", bg.border = "black")
circos.lines(1:100/100, y1, pch = 16, cex = 0.5)
circos.clear()

rect(0, 0, 1, 1)
text(0, 0, 0, adj = c(0.5, 1))
text(1, 0, 1, adj = c(0.5, 1))
text(0, 1, 1, adj = c(0.5, 0))


par(mar = c(1, 1, 1, 1))
circos.par("canvas.xlim" = c(0, 1), "canvas.ylim" = c(0, 1),"clock.wise" = FALSE, "gap.degree" = 0, points.overflow.warning = FALSE)
factors = letters[1:4]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(factors = factors, ylim = c(0, 1), bg.border = NA)
circos.updatePlotRegion(sector.index = "a", bg.border = "black")
circos.points(x1, y1, pch = 16, cex = 0.5)
circos.trackPlotRegion(factors = factors, ylim = c(0, 1), bg.border = NA)
circos.updatePlotRegion(sector.index = "a", bg.border = "black")
circos.lines(1:100/100, y1, pch = 16, cex = 0.5)
circos.clear()
box()
par(xpd = NA)
text(0, 0, 0, adj = c(0.5, 1))
text(1, 0, 1, adj = c(0.5, 1))
text(0, 1, 1, adj = c(0.5, 0))
@

\begin{figure}
\begin{center}
<<label=figpart, fig = TRUE, echo = FALSE, height=8, width=4, results=hide>>=
<<figpart>>
@
\end{center}
\caption{Part of the circos layout}
\label{fig:part}
\end{figure}

\subsection{Combine several parts of circos layouts}
Since the circos layout by {\tt circlize} is finally plotted in an ordinary R plotting system.
Two seperated circos layouts can be plotted together by some tricks. Here the key is 
{\tt par(new = TRUE)} which allows to draw a new figure on the previous canvas region.
{\bf Just remember the radius of the circos is always 1.}

The first example is to draw one outer circos and an inner circos (figure \ref{fig:nested}).

<<eval=FALSE, echo=TRUE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
factors = letters[1:4]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.text(0.5, 0.5, "outer circos")
})
circos.clear()

par(new = TRUE)
circos.par("canvas.xlim" = c(-2, 2), "canvas.ylim" = c(-2, 2))
factors = letters[1:3]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.text(0.5, 0.5, "inner circos")
})
circos.clear()
@


<<label=fignested, echo=FALSE, eval=FALSE>>=
library(circlize)

layout(rbind(c(1,1,2,2), c(0, 3, 3,0)))
par(mar = c(2, 2, 2, 2))
factors = letters[1:4]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.text(0.5, 0.5, "outer circos")
})
circos.clear()
box()
axis(side = 1)
axis(side = 2)

circos.par("canvas.xlim" = c(-2, 2), "canvas.ylim" = c(-2, 2))
factors = letters[1:3]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.text(0.5, 0.5, "inner circos")
})
circos.clear()
box()
axis(side = 1)
axis(side = 2)

factors = letters[1:4]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.text(0.5, 0.5, "outer circos")
})
circos.clear()

par(new = TRUE)
circos.par("canvas.xlim" = c(-2, 2), "canvas.ylim" = c(-2, 2))
factors = letters[1:3]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.text(0.5, 0.5, "inner circos")
})
circos.clear()
@

\begin{figure}
\begin{center}
<<label=fignested, fig = TRUE, echo = FALSE, height=6, width=6, results=hide>>=
<<fignested>>
@
\end{center}
\caption{An outer and an inner circos layout}
\label{fig:nested}
\end{figure}

The second example is drawing two seperated circos layouts in which every
circos only contains a half (figure \ref{fig:twoseperate}).

<<eval=FALSE, echo=TRUE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
factors = letters[1:4]
circos.par("canvas.xlim" = c(-1, 1.5), "canvas.ylim" = c(-1, 1.5),
    start.degree = -45)
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), bg.col = NA, bg.border = NA)
circos.updatePlotRegion(sector.index = "a")
circos.text(0.5, 0.5, "first one")
circos.updatePlotRegion(sector.index = "b")
circos.text(0.5, 0.5, "first one")

circos.clear()

par(new = TRUE)
circos.par("canvas.xlim" = c(-1.5, 1), "canvas.ylim" = c(-1.5, 1),
    start.degree = -45)
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), bg.col = NA, bg.border = NA)
circos.updatePlotRegion(sector.index = "d")
circos.text(0.5, 0.5, "second one")
circos.updatePlotRegion(sector.index = "c")
circos.text(0.5, 0.5, "second one")

circos.clear()
@

<<label=figseperated, echo=FALSE, eval=FALSE>>=
library(circlize)
layout(rbind(c(1,1,2,2), c(0, 3, 3,0)))
par(mar = c(2, 2, 2, 2))


factors = letters[1:4]
circos.par("canvas.xlim" = c(-1, 1.5), "canvas.ylim" = c(-1, 1.5),
    start.degree = -45)
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), bg.col = NA, bg.border = NA)
circos.updatePlotRegion(sector.index = "a")
circos.text(0.5, 0.5, "first one")
circos.updatePlotRegion(sector.index = "b")
circos.text(0.5, 0.5, "first one")

circos.clear()
box()
axis(side = 1)
axis(side = 2)

circos.par("canvas.xlim" = c(-1.5, 1), "canvas.ylim" = c(-1.5, 1), start.degree = -45)
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), bg.col = NA, bg.border = NA)
circos.updatePlotRegion(sector.index = "d")
circos.text(0.5, 0.5, "second one")
circos.updatePlotRegion(sector.index = "c")
circos.text(0.5, 0.5, "second one")

circos.clear()
box()
axis(side = 1)
axis(side = 2)

factors = letters[1:4]
circos.par("canvas.xlim" = c(-1, 1.5), "canvas.ylim" = c(-1, 1.5), start.degree = -45, points.overflow.warning = FALSE)
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), bg.col = NA, bg.border = NA)
circos.updatePlotRegion(sector.index = "a")
circos.text(0.5, 0.5, "first one")
circos.updatePlotRegion(sector.index = "b")
circos.text(0.5, 0.5, "first one")

circos.clear()

par(new = TRUE)
circos.par("canvas.xlim" = c(-1.5, 1), "canvas.ylim" = c(-1.5, 1), start.degree = -45)
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), bg.col = NA, bg.border = NA)
circos.updatePlotRegion(sector.index = "d")
circos.text(0.5, 0.5, "second one")
circos.updatePlotRegion(sector.index = "c")
circos.text(0.5, 0.5, "second one")

circos.clear()

@

\begin{figure}
\begin{center}
<<label=figseperated, fig = TRUE, echo = FALSE, height=6, width=6, results=hide>>=
<<figseperated>>
@
\end{center}
\caption{Two seperated circos layouts}
\label{fig:twoseperate}
\end{figure}

The third example is to draw sectors with different radius (figure \ref{fig:difrad}). In fact,
it draws four circos graphs in which only one sector of each graphs is plotted. Note links
can not be drawn in these different sectors because links can only be drawn in one circos
layout.

<<label=figdifrad, echo=TRUE, eval=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
factors = letters[1:4]
lim = c(1, 1.1, 1.2, 1.3)
for(i in 1:4) {
    circos.par("canvas.xlim" = c(-lim[i], lim[i]),
        "canvas.ylim" = c(-lim[i], lim[i]),
        "default.track.height" = 0.4)
    circos.initialize(factors = factors, xlim = c(0, 1))
    circos.trackPlotRegion(ylim = c(0, 1), bg.border = NA)
    circos.updatePlotRegion(sector.index = factors[i],
        bg.border = "black")
    circos.points(runif(10), runif(10), pch = 16)
    circos.clear()
    par(new = TRUE)
}
par(new = FALSE)
@

\begin{figure}
\begin{center}
<<label=figdifrad, fig = TRUE, echo = FALSE, results=hide>>=
<<figdifrad>>
@
\end{center}
\caption{Sectors with different radius}
\label{fig:difrad}
\end{figure}

\subsection{Draw outside and combine with canvas coordinate}
Sometimes it is very useful to draw something outside the plotting region of cell. (You can think it is
similar as {\tt par(xpd = NA)} setting.) The following is a simple
example to illustrate such circumstance (figure \ref{fig:outside}). The text is drawn outside the cell.


Since the finnal graph is drawn in an ordinary canvas plotting region, we can add additional graphs through
the traditional way. You can also see how {\tt text} and {\tt legend} work in the example code.

<<label=figoutside, echo=TRUE, eval=FALSE>>=
library(circlize)
set.seed(12345)
par(mar = c(1, 1, 1, 1))
factors = letters[1:4]
circos.par("canvas.xlim" = c(-1.5, 1.5), "canvas.ylim" = c(-1.5, 1.5),
    "gap.degree" = 10)
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.points(1:20/20, 1:20/20)
})
circos.lines(c(1/20, 0.5), c(1/20, 3), sector.index = "d",
    straight = TRUE)
circos.text(0.5, 3, "mark", sector.index = "d", adj = c(0.5, 0))

circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.points(1:20/20, 1:20/20)
})
text(0, 0, "this is\nthe center", cex = 1.5)
legend("bottomleft", pch = 1, legend = "this is the legend")
circos.clear()
@

\begin{figure}
\begin{center}
<<label=figoutside, fig = TRUE, echo = FALSE, results=hide>>=
<<figoutside>>
@
\end{center}
\caption{Draw outside the cell and combine with canvas coordinate}
\label{fig:outside}
\end{figure}

\subsection{Draw figures with {\tt layout}}
You can use {\tt layout} to arrange multiple figures together (also it is available from {\tt par(mfrow)}
or {\tt par(mfcol)}) (figure \ref{fig:layout}). 

<<label=figlayout, echo=TRUE, eval=FALSE>>=
library(circlize)

set.seed(12345)
rand_color = function() {
    return(rgb(runif(1), runif(1), runif(1)))
}

layout(matrix(1:9, 3, 3))
for(i in 1:9) {
    factors = 1:8
    par(mar = c(0.5, 0.5, 0.5, 0.5))
    circos.par(cell.padding = c(0, 0, 0, 0))
    circos.initialize(factors, xlim = c(0, 1))
    circos.trackPlotRegion(ylim = c(0, 1), track.height = 0.05,
        bg.col = sapply(1:8, function(x) rand_color()),
        bg.border = NA)
    for(i in 1:20) {
        se = sample(1:8, 2)
        col = rand_color()
        col = paste(col, "40", sep = "")
        circos.link(se[1], runif(2), se[2], runif(2), col = col)
    }
    circos.clear()
}
@

\begin{figure}
\begin{center}
<<label=figlayout, fig = TRUE, echo = FALSE, results=hide>>=
<<figlayout>>
@
\end{center}
\caption{Draw multiple figures by {\tt layout}}
\label{fig:layout}
\end{figure}

\end{document}
