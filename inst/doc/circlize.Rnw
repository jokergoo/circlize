% \VignetteIndexEntry{circlize}
% \VignetteDepends{circlize}
% \VignetteKeywords{circos}
% \VignetteKeywords{ideogram}
% \VignetteKeywords{circlize}
% \VignettePackage{circlize}

\documentclass{article}

\title{An introduction of the {\tt circlize} package}

\author{Zuguang Gu {\tt <z.gu@dkfz.de>}\\ German Cancer Research Center,\\ Heidelberg, Germany}

\usepackage{Sweave}
\usepackage{hyperref}

\begin{document}

\maketitle 

\section{Introduction}
Circos layout (\url{http://circos.ca}) is very useful to represent complicated informations, especially for genomic data.
The {\tt circlize} package implements the circos layout in R. The advantage is that R is nature-born to draw statistical
graphs, thus, types of plottings are not restricted by the package but by user's inspiration. The {\tt circlize} package allocates
and illustrates data which is from a certain category into a cell inside a circle and makes you
felling that you are plotting figures in a normal plotting coordinate.

Since most of the figures are composed of simple graphs, such as points, lines, polygon (for filled color) {\it et al},
so we just need to implement those low level functions to draw figures in circos layout.

Currently there are following functions that can be used for plotting, they are similar to the functions without {\tt circos.}
prefix from the traditional graph engine:

\begin{itemize}
  \item {\tt circos.points}: draw points in a cell
  \item {\tt circos.lines}: draw lines in a cell
  \item {\tt circos.rect}: draw rectangle in a cell
  \item {\tt circos.polygon}: draw polygon in a cell
  \item {\tt circos.text}: draw text in a cell
  \item {\tt circos.axis}: draw axis in a cell
  \item {\tt circos.link}: this maybe the unique feature for circos layout to represent relationships between elements.
\end{itemize}

For drawing points, lines and text through the whole track (among several sectors), the following functions are available:

\begin{itemize}
  \item {\tt circos.trackPoints}: this can be replaced by {\tt circos.points} through a {\tt for} loop.
  \item {\tt circos.trackLines}: this can be replaced by {\tt circos.lines} through a {\tt for} loop.
  \item {\tt circos.trackText}: this can be replaced by {\tt circos.text} through a {\tt for} loop.
\end{itemize}

Also, the function drawing histograms in the whole track is available:

\begin{itemize}
  \item {\tt circos.trackHist}
\end{itemize}

Functions to arrange the circos layout:

\begin{itemize}
  \item {\tt circos.trackPlotRegion}: create plotting regions of cells in one track
  \item {\tt circos.updatPlotRegion}: update one specified cell
  \item {\tt circos.par}: circos parameters
  \item {\tt circos.clear}: reset circos parameters and internal variables
\end{itemize}

Theoretically, you are able to draw most kinds of circos figures by the above functions. 
As you can see, all figures in the three vignettes are generated by {\tt circlize} package.

The following part of this vignette is structured as follows: First there is an example
to give a quick glance of how to draw a circos layout. Then it tells you the basic principle
(or the order of using the circos functions) for drawing. After that a detailed explaination
of circos parameters, coordinates and low level functions. Finally it would tell some tricks
for drawing more complicated circos plot.

\section{A quick glance}
Following is an example. First generate some data. There needs to have a factor to represent categories,
values on x-axis, and values on y-axis.

\begin{Schunk}
\begin{Sinput}
> set.seed(12345)
> n = 10000
> a = data.frame(factor = sample(letters[1:8], n, replace = TRUE),
+     x = rnorm(n), y = runif(n))
\end{Sinput}
\end{Schunk}

Initialize the layout. In this step, the function allocates sectors along
the circle according to ranges of x-values in different categories. E.g,
if there are two categories, range for x-values in the first category is {\tt c(0, 2)}
and range for x-values in the second category is {\tt c(0, 1)}, the first category
would hold approximately $67\%$ areas of the circle.
Here we only need x-values because all cells in a sector share the same
x-ranges. The order of the sectors in the circle is the order of levels of {\tt factors}.

\begin{Schunk}
\begin{Sinput}
> library(circlize)
> par(mar = c(1, 1, 1, 1), lwd = 0.1, cex = 0.7)
> circos.par("default.track.height" = 0.1)
> circos.initialize(factors = a$factor, x = a$x)
\end{Sinput}
\end{Schunk}

Draw the first track. Before drawing any track we need to know that all tracks should firstly be created by {\tt circos.trackPlotRegion}, then
those low level functions can be applied. X-lims for cells in the track have been already defined by the initialization step, 
so here we only need to specify the y-lims for each cell, either by {\tt y}
or {\tt ylim} argument. 

We also draw axis for each cell in the first track, The axis for each cell is drawn by {\tt panel.fun} argument. 
{\tt circos.trackPlotRegion} creates plotting region cell by cell and the {\tt panel.fun}
is actually executed after the creation of the plotting region for the cell. So {\tt panel.fun} actually means
drawing graphs in the ``current cell''. After that, draw points
through the whole track by {\tt circos.trackPoints}. Finally, add two texts in a certain cell
(the cell is specified by {\tt sector.index} argument).

Here what should be note is that the first track has a index number of 1.
Then an internal variable which traces the tracks would set the current track index to 1. So if the track
index is not specified in the plotting functions such as {\tt circos.trackPoints} and {\tt circos.text}
which are called after the creation of the track, the current track index would be assigned internally.
So if {\tt track.index} is not specifed, it means the track index is the current track index (it would be explained
in the following sections).

\begin{Schunk}
\begin{Sinput}
> circos.trackPlotRegion(factors = a$factor, y = a$y,
+     panel.fun = function(x, y) {
+         circos.axis()
+ })
> circos.trackPoints(a$factor, a$x, a$y, col = col,
+     pch = 16, cex = 0.5)
> circos.text(-1, 0.5, "left", sector.index = "a")
> circos.text(1, 0.5, "right", sector.index = "a")
\end{Sinput}
\end{Schunk}

Draw the second track. It is histograms among the track. The {\tt circos.trackHist}
can also create a new track because drawing histogram is really high level. So the track index for this track is 2.

\begin{Schunk}
\begin{Sinput}
> circos.trackHist(a$factor, a$x, bg.col = bgcol, col = NA)
\end{Sinput}
\end{Schunk}

Draw the third track. Different background colors for cells can be assigned. So it may highlight some
feature of the {\tt circlize} package. Here some meta data for a cell can be obtained by {\tt get.cell.meta.data}. This function needs
{\tt sector.index} and {\tt track.index} arguments, and if they are not specified, it means
it is the current sector index and the current track index.

\begin{Schunk}
\begin{Sinput}
> circos.trackPlotRegion(factors = a$factor, x = a$x, y = a$y,
+   panel.fun = function(x, y) {
+       grey = c("#FFFFFF", "#CCCCCC", "#999999")
+       i = get.cell.meta.data("sector.numeric.index")
+       circos.updatePlotRegion(bg.col = grey[i %% 3 + 1])
+       circos.points(x[1:10], y[1:10], col = "red", pch = 16, cex = 0.6)
+       circos.points(x[11:20], y[11:20], col = "blue", cex = 0.6)
+   })
\end{Sinput}
\end{Schunk}

You can update an existed cell by specifying {\tt sector.index} and {\tt track.index}.
The function erases graphs which have been drawn. Here we erase graphs in one cell in track 2, sector d
and re-draw some points.

\begin{Schunk}
\begin{Sinput}
> circos.updatePlotRegion(sector.index = "d", track.index = 2)
> circos.points(x = runif(100), y = runif(100))
\end{Sinput}
\end{Schunk}

Draw the fouth track. Here you can choose different line types.
\begin{Schunk}
\begin{Sinput}
> circos.trackPlotRegion(factors = a$factor, y = a$y)
> circos.trackLines(a$factor[1:100], a$x[1:100], a$y[1:100], type = "h")
\end{Sinput}
\end{Schunk}

Draw links. Links can be from point to point, point to interval or interval to interval.
Some of the arguments would be explained in the following sections.

\begin{Schunk}
\begin{Sinput}
> circos.link("a", 0, "b", 0, top.ratio = 0.9)
> circos.link("c", c(-0.5, 0.5), "d", c(-0.5,0.5), col = "red",
+     border = "blue", top.ratio = 0.2)
> circos.link("e", 0, "g", c(-1,1), col = "green", lwd = 2, lty = 2)
\end{Sinput}
\end{Schunk}


<<label=figexample, include=FALSE, echo=FALSE>>=
library(circlize)
set.seed(12345)
n = 10000
a = data.frame(factor = sample(letters[1:8], n, replace = TRUE), x = rnorm(n), y = runif(n))
for(le in levels(a$factor)) {
    a$x[a$factor == le] = a$x[a$factor == le] * runif(1)
}

par(mar = c(1, 1, 1, 1), lwd = 0.1, cex = 0.7)
circos.par("default.track.height" = 0.1, points.overflow.warning = FALSE)
circos.initialize(factors = a$factor, x = a$x)

bgcol = rep(c("#EFEFEF", "#CCCCCC"), 4)
col = rep(c("#FF000010", "#00FF0010"), 4)
circos.trackPlotRegion(factors = a$factor, y = a$y, panel.fun = function(x, y) {
    circos.axis()
})
circos.trackPoints(a$factor, a$x, a$y, col = col, pch = 16, cex = 0.5)
circos.text(-1,0.5, "left", sector.index = "a")
circos.text(1,0.5, "right", sector.index = "a")

circos.trackHist(a$factor, a$x, bg.col = bgcol, col = NA)

circos.trackPlotRegion(factors = a$factor, x = a$x, y = a$y, panel.fun = function(x, y) {
    grey = c("#FFFFFF", "#CCCCCC", "#999999")
    i = get.cell.meta.data("sector.numeric.index")
    circos.updatePlotRegion(bg.col = grey[i %% 3 + 1])
    circos.points(x[1:10], y[1:10], col = "red", pch = 16, cex = 0.6)
    circos.points(x[11:20], y[11:20], col = "blue", cex = 0.6)
})

circos.updatePlotRegion(sector.index = "d", track.index = 2)
circos.points(x = runif(100), y = runif(100))

circos.trackPlotRegion(factors = a$factor, y = a$y)
circos.trackLines(a$factor[1:100], a$x[1:100], a$y[1:100], type = "h")

circos.link("a", 0, "b", 0, top.ratio = 0.9)
circos.link("c", c(-0.5, 0.5), "d", c(-0.5,0.5), col = "red", border = "blue", top.ratio = 0.2)
circos.link("e", 0, "g", c(-1,1), col = "green", lwd = 2, lty = 2)

circos.clear()
@

\begin{figure}
\begin{center}
<<label=figexample, fig = TRUE, echo = FALSE>>=
<<figexample>>
@
\end{center}
\caption{An example for circos layout}
\label{fig:example}
\end{figure}

The final figure looks like figure \ref{fig:example}.

<<label=figtransformation, include=FALSE, echo=FALSE>>=
library(circlize)
layout(cbind(c(1, 0, 2, 0, 3)), height = c(2,0.5,2, 0.5, 4))
par(mar = c(2, 2, 2, 2))
x = 1:10
y = rnorm(10)
plot(x, y, type = "l", axes = FALSE, ann = FALSE)
text(2, 0, "text", cex = 2)
rect(5, -1, 7, 1)
box()
axis(side = 1)

par(mar = c(1, 1, 1, 1))
factors = letters[1:3]
circos.par("canvas.xlim" = c(-sqrt(3)/2, sqrt(3)/2), "canvas.ylim" = c(1/2*0.6, 1), start.degree = 30, "track.margin" = c(0, 0), "gap.degree" = 0, "clock.wise" = FALSE, points.overflow.warning = FALSE)
circos.initialize(factors = factors, xlim = c(1, 10))
circos.trackPlotRegion(factors = factors, ylim = range(y), track.height = 0.4, bg.border = NA)
circos.updatePlotRegion(sector.index = "a", track.index = 1, bg.border = "black")
circos.lines(x, y, sector.index = "a", track.index = 1, straight = TRUE)
circos.text(2, 0, "text", cex = 2)
circos.rect(5, -1, 7, 1)
circos.axis(h = "bottom")
circos.clear()

par(xpd = NA)
arrows(0, 1.33, 0, 1.07, code = 2)

par(mar = c(3, 3, 3, 3))
factors = letters[1:3]
circos.initialize(factors = factors, xlim = c(1, 10))
circos.trackPlotRegion(factors = factors, ylim = range(y), track.height = 0.4)
circos.updatePlotRegion(sector.index = "c", track.index = 1, bg.border = "black")
circos.lines(x, y, sector.index = "c", track.index = 1, straight = TRUE)
circos.text(2, 0, "text", cex = 2)
circos.rect(5, -1, 7, 1)
circos.axis(h = "bottom")
circos.clear()
box()
axis(side = 1)
axis(side = 2)
arrows(0, 1.5, 0, 1.07, code = 2)
@

\begin{figure}
\begin{center}
<<label=figtransformation, fig = TRUE, echo = FALSE, height=8.5, width=4>>=
<<figtransformation>>
@
\end{center}
\caption{Transformation between different coordinates}
\label{fig:transformation}
\end{figure}

\section{Details}
In this section, more details of the package would be explained.

\subsection{Rules to draw the circos layout}
The rules for drawing the circos layout is rather simple. It follows the sequence of
``initialize - create track - draw graphs - create track - draw graphs - ... - clear''.

\begin{enumerate}
  \item Initialize the layout using {\tt circos.initialize}. Since circos layout in fact visualizes data which is in categories,
        there should be a factor and a x-range to allocate categories into sectors.
  \item Create plotting regions for the new track and apply plottings. The new track is created just inside
        the previous created one and the index of the track is added by 1 automatically. Only after the creation of the track can you
        add other graphs on it. There are three ways to do the plotting job.
        \begin{enumerate}
            \item After the creation of the track. use low level function like {\tt circos.points},
                  {\tt circos.lines}, ... to draw graphs cell by cell. It allways involves
                  a {\tt for} loop.
            \item Use {\tt circis.trackPoints}, {\tt circos.trackLines}, ... to draw same style
                  of graphs through all cells simultaneously. However, it is not recommended because
                  it would make you a little confused.
            \item Use {\tt panel.fun} argument in {\tt circos.trackPlotRegion} to draw
                  graphs immediately after the creation of certain cell. {\tt panel.fun} needs
                  two arguments {\tt x} and {\tt y} which are x-values and y-values that
                  in the current category. This subset operation would be applied internally.
        \end{enumerate}
        Plotting regions for cells that have been created can be updated by {\tt circos.updatePlotRegion}.
        {\tt circos.updatePlotRegion} will erase every that you have already plotted in the plotting region of the cell.
        
        Low level functions such as {\tt circos.points} can be applied on any created cell by specifying
        {\tt sector.index} and {\tt track.index}.
  \item Call {\tt circos.clear} to do cleanings.
\end{enumerate}

Codes for the circos layout drawing rule would looks like (pseudo code):
\begin{Schunk}
\begin{Sinput}
> circos.initialize(factors, xlim)
> circos.trackPlotRegion(factors, ylim)
> for(sector.index in all.sector.index) {
+     circos.points(x, y, sector.index)
+     circos.lines(x, y, sector.index)
+ }
\end{Sinput}
\end{Schunk}

or like following:
\begin{Schunk}
\begin{Sinput}
> circos.trackPlotRegion(factors, ylim)
> circos.trackPoints(factors, x, y)
> circos.trackLines(factors, x, y)
\end{Sinput}
\end{Schunk}

or like following. This the most natural way I feel.
\begin{Schunk}
\begin{Sinput}
> circos.trackPlotRegion(factors, x, y, ylim,
+   panel.fun = function(x, y) {
+     circos.points(x, y)
+     circos.lines(x, y)
+ })
\end{Sinput}
\end{Schunk}

There is several internal variables keeping tracing of the current sector and track when applying {\tt circos.trackPlotRegion} and {\tt circos.updatePlotRegion}.
So although functions like {\tt circos.points}, {\tt circos.lines} need to specify the index for sector and track,
the values for sector index and the track index, by default, are taken as the current calculated ones. As a result,
if you draw points, lines, text, {\it et al} just after the creation of the track or cell, you do not need to set the sector
index and the track index explicitly and it is just drawn in the most nearly created cell.

Finally, in {\tt circlize} package, function with prefix {\tt circos.} would affect all cells in a track.

\subsection{Coordinate transformation}
There is a user coordinate in which the range for x-axis and y-axis is the range of data,
a polar coordinate to allocates different cells and a the canvas coordinate which really
draw the figures (figure \ref{fig:transformation}). The package would first transform the user
coordinate to a polar coordinate and finally transform into the canvas coordinate.

The finnal canvas coordinate is in fact an ordinary coordinate in R plotting system with
x-range from -1 to 1 and y-range from -1 to 1 by defaulte.

{\it {\bf It should be noted that the circos layout is always drawn inside the circle which has radius of 1 (unit
circle), from outside to inside. } }

However, for users, they only need to imagine that each cell is a normal rectangular plotting region (user coordinate) in
which x-lim and y-lim are ranges of data in that category respectively. The {\tt circlize} package would
know which cell you are drawing in.

<<label=figcoordinate, include=FALSE, echo=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
factors = factor(letters[1:10], levels = sample(letters[1:10], 10))
circos.par("cell.padding" = c(0, 0, 0, 0), points.overflow.warning = FALSE)
circos.initialize(factors = factors, xlim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10))
for(l in letters[1:10]) {
    circos.rect(0,0,10,10,sector.index = l, track.index = 2, col = "#FF000040")
}

for(l in 1:4) {
    circos.rect(0,0,10,10,sector.index = "a", track.index = l, col = "#0000FF40")
}
show.index()
circos.clear()

@

\begin{figure}
\begin{center}
<<label=figcoordinate, fig = TRUE, echo = FALSE>>=
<<figcoordinate>>
@
\end{center}
\caption{Coordinate in circos layout}
\label{fig:coordinate}
\end{figure}


\subsection{Sectors and tracks}

A circos layout is composed of sectors and tracks, as illustrated in figure \ref{fig:coordinate}.
The red circle is the track and the blue one is the sector. The intersection of a sector and 
a track is called a cell which can be thought as an imaginary plotting region for values in certain category. 

Sectors are first allocated and is determined by {\tt circos.initialize} and track allocation is then determined by {\tt circos.trackPlotRegion}.
{\tt circos.initialize} needs a category variable and data value which implicates the range of data in each category. The range
of data can be specified either by {\tt x} or {\tt xlim}.

\begin{Schunk}
\begin{Sinput}
> circos.initialize(factors, x)
> circos.initialize(factors, xlim)
\end{Sinput}
\end{Schunk}

There are something very important that should be noted in the initialization step. In this step, not only the width
of each sector is assigned, but also the order of each sector on the circle would be determined. 
{\bf Order of the sectors are determined by the order of levels of the factor}. So if you want to change the order
of the sectors, just change of the level of the {\tt factors} variable. If {\tt x} which is the x-value corresponding
to {\tt factors} is specified, the range for x-value in different category would be calculated according to {\tt factors}
automatically. And if {\tt xlim} is specified, it should be either a matrix which has same number of rows as the length
of the level of {\tt factors} or a two-element vector. If it is a two-element vector, it would be extended to a matrix which 
has the same number of rows as the length of {\tt factors} levels. Here, every row in {\tt xlim} corresponds to the x-ranges
of a category and the order of rows in {\tt xlim} corresponds to the order of levels of {\tt factors}.

Since all cells in one sector in different tracks share the same x-ranges, for each track, we only need to specify the y-ranges
for cells. Similar as {\tt circos.initialize}, {\tt circos.trackPlotRegion} can also receive either {\tt y} or {\tt ylim} arguments
to specify the range of y-values. There is also a {\tt force.ylim} argument to sepcify whether all cells in one track should
share the same y-ranges

\begin{Schunk}
\begin{Sinput}
> circos.trackPlotRegion(factors, y)
> circos.trackPlotRegion(factors, ylim)
\end{Sinput}
\end{Schunk}

In track creataion step, since all the sectors are already allocated in the circle, if {\tt factors} argument is not set, 
{\tt circos.trackPlotRegion} would create plotting regions for all available sectors. Also, levels of {\tt factors} do not
need to be specified explicitly because the order of sectors has already be determined. If {\tt factors} is just a vector, it 
would be converted to factor automatically. And finally if users just create cells in part of sectors in the track, in fact, the cells in remaining
unspecified sectors would also be created, but with no borders (pretending they are not created).


<<label=figregion, include=FALSE, echo=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1), "xaxs" = "i", "yaxs" = "i")
factors = letters[1:8]
circos.par("canvas.xlim" = c(0, 1), "canvas.ylim" = c(0, 1), "gap.degree" = 3, "start.degree" = 20, "track.margin" = c(0.05, 0.05), "clock.wise" = FALSE)
circos.initialize(factors = factors, xlim = c(0, 10))

circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.1, bg.border = NA, bg.col = "#E41A1C", panel.fun = function(x, y) {
    xlim = get.cell.meta.data("xlim")
    ylim = get.cell.meta.data("ylim")
    cell.xlim = get.cell.meta.data("cell.xlim")
    cell.ylim = get.cell.meta.data("cell.ylim")
    circos.rect(xlim[1], ylim[1], xlim[2], ylim[2], col = "#377EB8", border = "black", lwd = 2)
    circos.rect(cell.xlim[1], cell.ylim[2], cell.xlim[2], cell.ylim[2]+(cell.ylim[2]-cell.ylim[1])/2, col = "#984EA3", border = NA)
    circos.rect(cell.xlim[1], cell.ylim[1]-(cell.ylim[2]-cell.ylim[1])/2, cell.xlim[2], cell.ylim[1], col = "#984EA3", border = NA)
    circos.lines(0:10, runif(11)*10)
    circos.rect(cell.xlim[1], cell.ylim[1], cell.xlim[2], cell.ylim[2], lwd = 2, lty = 2)
})
circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.3, bg.border = NA, bg.col = "#E41A1C", panel.fun = function(x, y) {
    xlim = get.cell.meta.data("xlim")
    ylim = get.cell.meta.data("ylim")
    cell.xlim = get.cell.meta.data("cell.xlim")
    cell.ylim = get.cell.meta.data("cell.ylim")
    circos.rect(xlim[1], ylim[1], xlim[2], ylim[2], col = "#377EB8", border = "black", lwd = 2)
    circos.rect(cell.xlim[1], cell.ylim[2], cell.xlim[2], cell.ylim[2]+(cell.ylim[2]-cell.ylim[1])/6, col = "#984EA3", border = NA)
    circos.rect(cell.xlim[1], cell.ylim[1]-(cell.ylim[2]-cell.ylim[1])/6, cell.xlim[2], cell.ylim[1], col = "#984EA3", border = NA)
    circos.lines(0:10, runif(11)*10)
    circos.rect(cell.xlim[1], cell.ylim[1], cell.xlim[2], cell.ylim[2], lwd = 2, lty = 2)
})
circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.1, bg.border = NA, bg.col = "#E41A1C", panel.fun = function(x, y) {
    xlim = get.cell.meta.data("xlim")
    ylim = get.cell.meta.data("ylim")
    cell.xlim = get.cell.meta.data("cell.xlim")
    cell.ylim = get.cell.meta.data("cell.ylim")
    circos.rect(xlim[1], ylim[1], xlim[2], ylim[2], col = "#377EB8", border = "black", lwd = 2)
    circos.rect(cell.xlim[1], cell.ylim[2], cell.xlim[2], cell.ylim[2]+(cell.ylim[2]-cell.ylim[1])/2, col = "#984EA3", border = NA)
    circos.rect(cell.xlim[1], cell.ylim[1]-(cell.ylim[2]-cell.ylim[1])/2, cell.xlim[2], cell.ylim[1], col = "#984EA3", border = NA)
    circos.lines(0:10, runif(11)*10)
    circos.rect(cell.xlim[1], cell.ylim[1], cell.xlim[2], cell.ylim[2], lwd = 2, lty = 2)
})

x = seq(0, 1, length = 1000)
y = sqrt(1^2 - x^2)
lines(x, y, lty = 3, lwd = 2)

x = seq(0, 0.8, length = 1000)
y = sqrt(0.8^2 - x^2)
lines(x, y, lty = 3, lwd = 2)

x = seq(0, 0.4, length = 1000)
y = sqrt(0.4^2 - x^2)
lines(x, y, lty = 3, lwd = 2)

x = seq(0, 0.2, length = 1000)
y = sqrt(0.2^2 - x^2)
lines(x, y, lty = 3, lwd = 2)

draw.sector(center = c(0, 0), start = 20, end = 23, rou1 = 1, rou2 = 0.2, col = "#4DAF4A")
draw.sector(center = c(0, 0), start = 65, end = 68, rou1 = 1, rou2 = 0.2, col = "#4DAF4A")

circos.text(5, 5, "plotting region", sector.index = "a", track.index = 2)
circos.text(5, 10.5, "cell.padding[3]", sector.index = "a", track.index = 2)
circos.text(5, -0.5, "cell.padding[1]", sector.index = "a", track.index = 2)
circos.text(-0.5, 5, "cell.padding[2]", direction = "vertical_right", sector.index = "a", track.index = 2)
circos.text(10.5, 5, "cell.padding[4]", direction = "vertical_right", sector.index = "a", track.index = 2)
circos.text(5, -2, "track.margin[1]", sector.index = "a", track.index = 2)
circos.text(5, 12, "track.margin[2]", sector.index = "a", track.index = 2)
circos.text(-1.5, 5, "gap.degree", direction = "vertical_right", sector.index = "a", track.index = 2)
circos.text(11.5, 5, "gap.degree", direction = "vertical_right", sector.index = "a", track.index = 2)
circos.clear()
@

\begin{figure}
\begin{center}
<<label=figregion, fig = TRUE, echo = FALSE>>=
<<figregion>>
@
\caption{Regions for a cell}
\label{fig:region}
\end{center}
\end{figure}

<<label=figdirection, include=FALSE, echo=FALSE>>=
par(mfrow = c(2, 1))
par(mar = c(1, 1, 1, 1))
factors = letters[1:8]
circos.initialize(factors = factors, xlim = c(0, 10))
circos.par("track.margin" = c(0.1, 0.1), points.overflow.warning = FALSE)
circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.4, panel.fun = function(x, y) {
    circos.text(5, 5, get.cell.meta.data("sector.index"))
    xlim = get.cell.meta.data("xlim")
    ylim = get.cell.meta.data("ylim")
    circos.lines(xlim, c(0, 0))
    circos.lines(c(9, 10), c(0.5, 0))
    circos.lines(c(9, 10), c(-0.5, 0))
    circos.lines(c(0, 0), xlim)
    circos.lines(c(0.5, 0), c(9, 10))
    circos.lines(c(-0.5, 0), c(9, 10))
})
circos.clear()

x = seq(-0.7, 0.7, length = 100)
d = cbind(x, sqrt(1 - x^2))
lines(d)
arrows(d[2,1], d[2,2], d[1,1], d[1,2])

x = seq(-0.7, 0.7, length = 100)
d = cbind(x, -sqrt(1 - x^2))
lines(d)
arrows(d[99,1], d[99,2], d[100,1], d[100,2])

text(0, 0, 'circos.par("clock.wise" = FALSE)', cex = 0.6)

par(mar = c(1, 1, 1, 1))
factors = letters[1:8]
circos.par("track.margin" = c(0.1, 0.1), clock.wise = TRUE)
circos.initialize(factors = factors, xlim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.4, panel.fun = function(x, y) {
    circos.text(5, 5, get.cell.meta.data("sector.index"))
    xlim = get.cell.meta.data("xlim")
    ylim = get.cell.meta.data("ylim")
    circos.lines(xlim, c(0, 0))
    circos.lines(c(9, 10), c(0.5, 0))
    circos.lines(c(9, 10), c(-0.5, 0))
    circos.lines(c(0, 0), xlim)
    circos.lines(c(0.5, 0), c(9, 10))
    circos.lines(c(-0.5, 0), c(9, 10))
})
circos.clear()

x = seq(-0.7, 0.7, length = 100)
d = cbind(x, sqrt(1 - x^2))
lines(d)
arrows(d[99,1], d[99,2], d[100,1], d[100,2])


x = seq(-0.7, 0.7, length = 100)
d = cbind(x, -sqrt(1 - x^2))
lines(d)
arrows(d[2,1], d[2,2], d[1,1], d[1,2])
text(0, 0, 'circos.par("clock.wise" = TRUE)', cex = 0.6)
@

\begin{figure}
\begin{center}
<<label=figdirection, fig = TRUE, echo = FALSE, width=4, height=8>>=
<<figdirection>>
@
\end{center}
\caption{Sector directions}
\label{fig:direction}
\end{figure}


\subsection{Circos parameters}
Some basic parameters for the circos layout can be set through {\tt circos.par}. The paramters
are as follows, note some parameters can only be assigned before the initialization of the circos layout.

\begin{itemize}
    \item {\tt start.degree}: The starting degree which the circle begin to draw. Note this degree is measured 
          in the standard polar coordinate which means it is anti-clockwise.
    \item {\tt gap.degree}: Gap between two neighbour sectors. Note a gap is allocated first in front of the first sector. See figure \ref{fig:region}.
    \item {\tt track.margin}: Like {\tt margin} in Cascading Style Sheets (CSS), it is the blank area
          out of the plotting region, also outside of the borders. Since left and right margin are controlled
          by {\tt gap.degree}, only bottom and top margin need to be set. The value for the {\tt track.margin}
          is the percentage according to the radius of the unit circle. See figure \ref{fig:region}.
    \item {\tt cell.padding}: Padding of the cell. Like {\tt padding} in Cascading Style Sheets
          (CSS), it is the blank area around the plotting regions, but within the borders.
          The paramter has four values, which controls the bottom, left, top and right padding
          respectively. The four values are all percentages in which the first and the third padding
          values are the percentages according to the range of values on y-axis and the second and
          fourth values are the percentages according to the range of values on x-axis. See figure \ref{fig:region}.
    \item {\tt unit.circoe.segments}: Since curves are simulated by a series of straight lines,
          this parameter controls the amout of segments to represent a curve. The minimal length
          of the line segmentation is the length of the unit circle divided by {\tt unit.circoe.segments}.     
    \item {\tt default.track.height}: The default height of tracks. It is the percentage according to the radius
          of the unit circle. The height includes the top and bottom cell paddings but not the margins.
          However, the definition would be changed in future version because I think it would be more 
          reasonable to include the margins in the track.
    \item {\tt points.overflow.warning}: Since each cell is in fact not a plotting region but only
          an ordinary rectangle, it does not eliminate points that are plotted out of
          the region. So if some points are out of the plotting region, by default, the 
          package would continue drawing the points and print warnings. But in some 
          circumstances, draw something out of the plotting region is useful, such as draw
          some legend or text. Set this value to {\tt FALSE} to turn off the warnings.
    \item {\tt canvas.xlim}: The coordinate for the canvas. By default, the package draws unit circle, so
          the xlim for the canvas would be {\tt c(-1, 1)}. However, you can set it to a more broad
          interval if you want to draw other things out of the circle. By choose proper
          {\tt canvas.xlim} and {\tt canvas.ylim}, you can draw part of the circle. E.g. setting
          {\tt canvas.xlim} to {\tt c(0, 1)} and {\tt canvas.ylim} to {\tt c(0, 1)} would only draw
          circle in the region of {\tt (0, pi/2)}.
    \item {\tt canvas.ylim}: The coordinate for the canvas.
    \item {\tt clock.wise}: The order of drawing sectors. Default is {\tt TRUE} which means anticlockwise (figure \ref{fig:direction}).
          But note that inside each cell, the direction of x-axis is always anticlockwise.
\end{itemize}

Parameters related to the allocation of sectors can be changes after the initialization of the layout.
So {\tt start.degree}, {\tt gap.degree}, {\tt canvas.xlim}, {\tt canvas.ylim} and {\tt clock.wise} can only
be modified before {\tt circos.initialize}. The second and the fourth element of {\tt cell.padding} can not
be modified either.

<<label=figlines, include=FALSE, echo=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
factors = letters[1:7]
circos.par(points.overflow.warning = FALSE)
circos.initialize(factors = factors, xlim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.5)
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "a")
circos.text(5, 9, "type = 'l'", sector.index = "a")
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "b", type = "o")
circos.text(5, 9, "type = 'o'", sector.index = "b")
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "c", type = "h")
circos.text(5, 9, "type = 'h'", sector.index = "c")
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "d", type = "s")
circos.text(5, 9, "type = 's'", sector.index = "d")
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "e", area = TRUE)
circos.text(5, 9, "type = 'l', area = TRUE", sector.index = "e")
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "f", type = "o", area = TRUE)
circos.text(5, 9, "type = 'o', area = TRUE", sector.index = "f")
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "g", type = "s", area = TRUE)
circos.text(5, 9, "type = 's', area = TRUE", sector.index = "g")
circos.clear()
@

\begin{figure}
\begin{center}
<<label=figlines, fig = TRUE, echo = FALSE>>=
<<figlines>>
@
\end{center}
\caption{Line style settings}
\label{fig:lines}
\end{figure}

\subsection{Points}
Drawing points is similar as {\tt points} function.


\subsection{Lines}
Parameters for drawing lines by {\tt circos.lines} are similar to {\tt lines} function, 
as illustrated in figure \ref{fig:lines}. One additional feature is that the areas under lines can be 
specified by {\tt area} argument. Also the base line for the area can be set by {\tt area.baseline}.

Straight lines will be transformed to curves when mapping to the circos layout. Normally, 
curves can be approximated by a series of segmentation of straight lines. With more segmentations,
there would be better approximations, but with larger size if you generate the graph as pdf format, especially
if you want to huge genomic data. So, in this package, the number of the segmentation can be controlled by {\tt circos.par("unit.circoe.segments")}.
The length of minimal segment is the length of circumference of the unit circle divided by 
{\tt circos.par(unit.circoe.segments)}. If you do not want such curve-transformations (such as some
radical lines), you can set {\tt straight} argument to {\tt TRUE}. 

<<label=figtext, include=FALSE, echo=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
factors = letters[1:4]
circos.par(points.overflow.warning = FALSE)
circos.initialize(factors = factors, xlim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.5, panel.fun = function(x, y) {
    circos.text(5, 9, "default_default", direction = "default")
    circos.text(0, 5, "vertical_left", direction = "vertical_left")
    circos.text(10, 5, "vertical_right", direction = "vertical_right")
    circos.text(5, 5, "horizontal", direction = "horizontal")
    circos.text(5, 1, "arc_arc_arc_arc_arc", direction = "arc")
})
circos.clear()
@

\begin{figure}
\begin{center}
<<label=figtext, fig = TRUE, echo = FALSE>>=
<<figtext>>
@
\end{center}
\caption{Text direction settings}
\label{fig:text}
\end{figure}


\subsection{Text}
Only the direction of text by {\tt circos.text} should be noted, as illustrated in figure \ref{fig:text}.
Only five direction of text is allowed which are in {\tt c("default", "vertical\_left", "vertical\_right", "horizontal", "arc")}.

\begin{itemize}
    \item {\tt default}: direction of the tangent.
    \item {\tt vertical\_left}: direction of radius, facing left at $90^\circ$ position.
    \item {\tt vertical\_left}: direction of radius, facing right at $90^\circ$ position.
    \item {\tt horizontal}: horizontal direction in the canvas coordinate.
    \item {\tt arc}: direction of the arc.
\end{itemize}

<<label=figaxis, include=FALSE, echo=FALSE>>=
library(circlize)

par(mar = c(1, 1, 1, 1))
factors = letters[1:8]
circos.par(points.overflow.warning = FALSE)
circos.initialize(factors = factors, xlim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.1, bg.border = NA, panel.fun = function(x, y) {
    circos.text(5, 10, get.cell.meta.data("sector.index"))
})

circos.trackPlotRegion(factors = factors, ylim = c(0, 10))
circos.axis(sector.index = "a")
circos.axis(sector.index = "b", direction = "inside")
circos.axis(sector.index = "c", h = "bottom")
circos.axis(sector.index = "d", h = "bottom", direction = "inside")
circos.axis(sector.index = "e", h = 5, major.at = c(1, 3, 5, 7, 9))
circos.axis(sector.index = "f", h = 5, major.at = c(1, 3, 5, 7, 9), labels = c("a", "c", "e", "g", "f"), minor.ticks = 0)
circos.axis(sector.index = "g", h = 5, major.at = c(1, 3, 5, 7, 9), labels = c("a", "c", "e", "g", "f"), major.tick = FALSE)
circos.axis(sector.index = "h", h = 2, major.at = c(1, 3, 5, 7, 9), labels = c("a", "c", "e", "g", "f"), major.tick.percentage = 0.3, labels.away.percentage = 0.2, minor.ticks = 2, labels.direction = "vertical_right")
circos.clear()
@

\begin{figure}
\begin{center}
<<label=figaxis, fig = TRUE, echo = FALSE>>=
<<figaxis>>
@
\end{center}
\caption{Axis settings}
\label{fig:axis}
\end{figure}

\subsection{Axis}
Because there may be no space to draw y-axis, only x-axis for each cell is supported by {\tt circos.axis}, as illustrated in figure \ref{fig:axis}.
A lot of styles for axis can be set such as the position and length of major ticks, the number of minor ticks,
the position and direction of the axis labels and the position of the x-axis.


<<label=figlink, include=FALSE, echo=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
factors = letters[1:8]
circos.par(points.overflow.warning = FALSE)
circos.initialize(factors = factors, xlim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 1), bg.col = "grey", bg.border = NA, track.height = 0.05)

circos.link("a", 5, "c", 5)
circos.link("b", 5, "d", c(4, 6))
circos.link("a", c(2, 3), "f", c(4, 6))

circos.clear()
@

\begin{figure}
\begin{center}
<<label=figlink, fig = TRUE, echo = FALSE>>=
<<figlink>>
@
\end{center}
\caption{Link settings}
\label{fig:link}
\end{figure}



<<label=figquadratic, include=FALSE, echo=FALSE>>=
degree.minus = function(to, from, min.zero = TRUE) {
    if(min.zero) {
        return((to - from) %% 360)
    } else {
        if((to - from) %% 360 == 0) {
            return(360)
        } else {
            return((to - from) %% 360)
        }
    }
}
rotate.parabola = function(theta1, theta2, rou1, rou2 = rou1, theta = (theta1+theta2)/2, 
    rou = rou1 * abs(cos(degree.minus(theta1, theta2)/2/180*pi))*rou.ratio, rou.ratio = 0.5,
    n = 1001) {
    
    while(theta2 < theta1) {
        theta2 = theta2 + 360
    }
    
    delta_theta = degree.minus(theta2, theta1)
    
    flag = 0
    if(delta_theta > 180) {
        theta = theta + 180
        flag = 1
    }
    
    # y^2 = kx, y = +-sqrt(kx)
    b = rou1 * abs(sin(degree.minus(theta2, theta1)/2/180*pi))
    a = rou1 * abs(cos(degree.minus(theta2, theta1)/2/180*pi)) - rou
    k = b^2/a
    
    if(n %% 2 == 0) {
        n = n + 1
    }
    n.half = (n - 1) / 2
    x = numeric(n)
    y = numeric(n)
    x = c(n.half:1/n.half, 0, 1:n.half/n.half)*a
    y[1:n.half] = sqrt(k*x[1:n.half])
    y[n.half + 1] = 0
    y[1:n.half + n.half + 1] = -sqrt(k*x[1:n.half + n.half + 1])
    
    alpha = numeric(n)
    
    alpha[1:n.half] = atan(y[1:n.half]/x[1:n.half])*180/pi
    alpha[1:n.half + n.half + 1] = atan(y[1:n.half + n.half + 1]/x[1:n.half + n.half + 1])*180/pi
    alpha[n.half + 1] = 90
    
    d = sqrt(x^2 + y^2)
    x = d*cos((alpha + theta)/180*pi)
    y = d*sin((alpha + theta)/180*pi)
    
    center.x = rou*cos(theta/180*pi)
    center.y = rou*sin(theta/180*pi)
    
    x = x + center.x
    y = y + center.y
    
    if(!flag) {
        x = rev(x)
        y = rev(y)
    }

    return(cbind(x, y))
}

polar2Cartesian = function(d) {
    theta = d[, 1]/360 * 2 *pi
    rou = d[, 2]
    x = rou * cos(theta)
    y = rou * sin(theta)
    return(cbind(x, y))
}
par(mar = c(1, 1, 1, 1))
plot(c(-1, 1), c(-1, 1), axes = FALSE, ann = FALSE ,type = "n")
draw.sector(center = c(0, 0), start.degree = 0, end.degree = 360, rou1 = 1, col = "white", border = "black")
d= rotate.parabola(theta1 = 270, theta2 = 330, rou1 = 1, rou.ratio = 0.5)
lines(rbind(d, d[1, ]))
lines(c(cos(300/180*pi), cos(120/180*pi)), c(sin(300/180*pi), sin(120/180*pi)))
points(0, 0, pch = 16)
lines(c(0, sqrt(3)/4)+0.01, c(0, -3/4)+0.01, lwd = 4, col = "red")
lines(c(0, sqrt(3)/4/2)-0.01, c(0, -3/4/2)-0.01, lwd = 4, col = "blue")
@

\begin{figure}
\begin{center}
<<label=figquadratic, fig = TRUE, echo = FALSE>>=
<<figquadratic>>
@
\end{center}
\caption{Additional settings for links}
\label{fig:quadratic}
\end{figure}


\subsection{Links}
Links can be drawn by {\tt circos.link} from points and intervals (figure \ref{fig:link}). If both ends are points, then the link is represented
as a line. If one of the ends is an interval, the link would be a belt. The link is in fact a quadratic curve.

The height of the link can be controlled by {\tt top.ratio} argument in {\tt circos.link} which is the ratio between the length of blue line and 
the red line (figure \ref{fig:quadratic}). Links do not hold any position of track.


\subsection{The {\tt panel.fun} argument in {\tt circos.trackPlotRegion}}
{\tt panel.fun} argument in {\tt circos.trackPlotRegion} is useful to apply plottings as soon as the cell has been created. This self-defined
function need two arguments {\tt x} and {\tt y} which are data points in the cell. The value for such values are extracted from {\tt x} and {\tt y}
in {\tt circos.trackPlotRegion} function according to the category argument {\tt factors}. In the following example, {\tt x} in category {\tt a} in {\tt panel.fun}
would be {\tt 1:3} and {\tt y} values are {\tt 5:3}.

\begin{Schunk}
\begin{Sinput}
> factors = c("a", "a", "a", "b", "b")
> x = 1:5
> y = 5:1
> circos.trackPlotRegion(factors = factors, x = x, y = y,
+     panel.fun = function(x, y) {
+         circos.points(x, y)
+     })
\end{Sinput}
\end{Schunk}


\subsection{High level plotting functions}
With those low level function such as {\tt circos.lines}, {\tt circos.lines},
more high level functions can be easily written. The package provides a high
level function {\tt circos.trackHist} which draws the histogram or the density
distribution of data (figure \ref{fig:hist}). So users would know how to implement other
high level function to support graphs such as barplot, heatmap, et al. accroding to the source code of {\tt circos.trackHist}.

In figure \ref{fig:hist}, the first track is histograms in which all the ylim are same.
The second track is histograms in which {\tt force.ylim} is {\tt FALSE}.
The third and the fourth tracks are density distributions in which ylims
are forced same or different.


<<label=fighist, include=FALSE, echo=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
x = rnorm(2600)
factors = sample(letters, 2600, replace = TRUE)
circos.initialize(factors = factors, x = x)
circos.trackHist(factors = factors, x = x, track.height = 0.1, col = "#CCCCCC", border = "#CCCCCC")
circos.trackHist(factors = factors, x = x, force.ylim = FALSE, track.height = 0.1, col = "#CCCCCC", border = "#CCCCCC")
circos.trackHist(factors = factors, x = x, draw.density = TRUE, track.height = 0.1, col = "#CCCCCC", border = "#CCCCCC")
circos.trackHist(factors = factors, x = x, draw.density = TRUE, force.ylim = FALSE, track.height = 0.1, col = "#CCCCCC", border = "#CCCCCC")

circos.clear()

@

\begin{figure}
\begin{center}
<<label=fighist, fig = TRUE, echo = FALSE>>=
<<fighist>>
@
\end{center}
\caption{Drawing histograms}
\label{fig:hist}
\end{figure}

\subsection{Other functions}
{\tt draw.sector} can be used to draw sectors or part of a ring. This is useful if you want to hightlight some part of your circos plot.
As you can think, this function need argument of the position of circle center, the start degree and the end degree for the sector, 
and radius for two edges (or one edge) of the arc. These information can be obtained by {\tt get.cell.meta.data}. In {\tt get.cell.meta.data},
{\tt xplot} is the start and end degree for the cell and {\tt yplot} is the top radius and the bottom radius for the top and bottom edges
of the cell. An example is as follows and see \ref{fig:sectorhighlight}.


<<label=sectorhighlight, include=TRUE, echo=TRUE>>=
library(circlize)
par(mar = c(1,1,1,1))
factors = letters[1:8]
circos.par(gap.degree = 5, track.margin = c(0.05, 0.05))
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), bg.col = "pink")
circos.trackPlotRegion(ylim = c(0, 1), bg.col = "orange")

xplot.a = get.cell.meta.data("xplot", sector.index = "a", track.index = 1)
yplot.a = get.cell.meta.data("yplot", sector.index = "a", track.index = 1)
margin.a = get.cell.meta.data("track.margin", sector.index = "a", track.index = 1)
gap.degree = circos.par("gap.degree")
draw.sector(center = c(0, 0), start.degree = xplot.a[1] - gap.degree/2,
    end.degree = xplot.a[2] + gap.degree/2,
    rou1 = yplot.a[2]+ margin.a[2], border = NA, col = "#FF000040")

draw.sector(center = c(0, 0), start.degree = 0, end.degree = 360,
	rou1 = yplot.a[2]+ margin.a[2], rou2 = yplot.a[1] - margin.a[1],
	border = NA, col = "#0000FF40")

xplot.d = get.cell.meta.data("xplot", sector.index = "d", track.index = 1)
yplot.d2 = get.cell.meta.data("yplot", sector.index = "d", track.index = 2)
margin.d2 = get.cell.meta.data("track.margin", sector.index = "d", track.index = 2)
xplot.e = get.cell.meta.data("xplot", sector.index = "e", track.index = 1)

draw.sector(center = c(0, 0), start.degree = xplot.e[2] - gap.degree/2,
    end.degree = xplot.d[1] + gap.degree/2,
    rou1 = yplot.d2[2]+ margin.d2[2], rou2 = yplot.d2[1] - margin.d2[1],
    border = NA, col = "#00FF0040")
show.index()
circos.clear()
@

\begin{figure}
\begin{center}
<<label=sectorhighlight, fig = TRUE, echo = FALSE>>=
<<sectorhighlight>>
@
\end{center}
\caption{Hightlight sectors}
\label{fig:sectorhighlight}
\end{figure}


\subsection{Do not forget {\tt circos.clear}}
You should call {\tt circos.clear} to complete end the circos plottings. Because there are several
global variables tracing the status of the plot such as the index and position for the newest track.
Such variables should be reset before drawing any new circos figures.

\section{Advanced plottings}

\subsection{Draw part of the circos layout}
{\tt canvas.xlim} and {\tt canvas.ylim} in {\tt circos.par} is useful to draw only part of circle. Here
only sector between $0^\circ$ to $90^\circ$ are plotted (figure \ref{fig:part}). Codes are as follows. First, four sectors
with the same length are initialized. Then only the first sector is drawn with points and lines.

\begin{Schunk}
\begin{Sinput}
> par(mar = c(1, 1, 1, 1))
> circos.par("canvas.xlim" = c(0, 1), "canvas.ylim" = c(0, 1),
+ "clock.wise" = FALSE)
> factors = letters[1:4]
> circos.initialize(factors = factors, xlim = c(0, 1))
> circos.trackPlotRegion(factors = factors, ylim = c(0, 1), bg.border = NA)
> circos.updatePlotRegion(sector.index = "a", bg.border = "black")
> circos.points(runif(100), runif(100), pch = 16, cex = 0.5)
> circos.trackPlotRegion(factors = factors, ylim = c(0, 1), bg.border = NA)
> circos.updatePlotRegion(sector.index = "a", bg.border = "black")
> circos.lines(1:100/100, runif(100), pch = 16, cex = 0.5)
> circos.clear()
\end{Sinput}
\end{Schunk}


<<label=figpart, include=FALSE, echo=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
circos.par("canvas.xlim" = c(0, 1), "canvas.ylim" = c(0, 1),"clock.wise" = FALSE, "gap.degree" = 0, points.overflow.warning = FALSE)
factors = letters[1:4]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(factors = factors, ylim = c(0, 1), bg.border = NA)
circos.updatePlotRegion(sector.index = "a", bg.border = "black")
circos.points(runif(100), runif(100), pch = 16, cex = 0.5)
circos.trackPlotRegion(factors = factors, ylim = c(0, 1), bg.border = NA)
circos.updatePlotRegion(sector.index = "a", bg.border = "black")
circos.lines(1:100/100, runif(100), pch = 16, cex = 0.5)
circos.clear()
@

\begin{figure}
\begin{center}
<<label=figpart, fig = TRUE, echo = FALSE>>=
<<figpart>>
@
\end{center}
\caption{Part of the circos layout}
\label{fig:part}
\end{figure}

\subsection{Combine two parts of circos layouts}
Since the circos layout by {\tt circlize} finally plotted in an ordinary R plotting system.
Two seperated circos layouts can be plotted together by some tricks. Here the key is 
{\tt par(new = TRUE)} which allows to draw a new figure on the previous plotting region.
Just remember the radius of the circos is always 1.

The first example is to draw one outer circos and an inner circos (figure \ref{fig:nested}).

\begin{Schunk}
\begin{Sinput}
> library(circlize)
> par(mar = c(1, 1, 1, 1))
> factors = letters[1:4]
> circos.initialize(factors = factors, xlim = c(0, 1))
> circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
+     circos.text(0.5, 0.5, "outer circos")
+ })
> circos.clear()
> 
> par(new = TRUE)
> circos.par("canvas.xlim" = c(-2, 2), "canvas.ylim" = c(-2, 2))
> factors = letters[1:3]
> circos.initialize(factors = factors, xlim = c(0, 1))
> circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
+     circos.text(0.5, 0.5, "inner circos")
+ })
> circos.clear()
\end{Sinput}
\end{Schunk}


<<label=fignested, include=FALSE, echo=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
factors = letters[1:4]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.text(0.5, 0.5, "outer circos")
})
circos.clear()

par(new = TRUE)
circos.par("canvas.xlim" = c(-2, 2), "canvas.ylim" = c(-2, 2))
factors = letters[1:3]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.text(0.5, 0.5, "inner circos")
})
circos.clear()
@

\begin{figure}
\begin{center}
<<label=fignested, fig = TRUE, echo = FALSE>>=
<<fignested>>
@
\end{center}
\caption{An outer and an inner circos layout}
\label{fig:nested}
\end{figure}

The second example is to draw to seperated circos layouts in which every
circos only contains a half (figure \ref{fig:twoseperate}).

\begin{Schunk}
\begin{Sinput}
> library(circlize)
> par(mar = c(1, 1, 1, 1))
> factors = letters[1:4]
> circos.par("canvas.xlim" = c(-1, 1.2), "canvas.ylim" = c(-1, 1.2),
+     start.degree = -45)
> circos.initialize(factors = factors, xlim = c(0, 1))
> circos.trackPlotRegion(ylim = c(0, 1), bg.col = NA, bg.border = NA)
> circos.updatePlotRegion(sector.index = "a")
> circos.text(0.5, 0.5, "first one")
> circos.updatePlotRegion(sector.index = "b")
> circos.text(0.5, 0.5, "first one")
>
> circos.clear()
>
> par(new = TRUE)
> circos.par("canvas.xlim" = c(-1.2, 1), "canvas.ylim" = c(-1.2, 1),
+     start.degree = -45)
> circos.initialize(factors = factors, xlim = c(0, 1))
> circos.trackPlotRegion(ylim = c(0, 1), bg.col = NA, bg.border = NA)
> circos.updatePlotRegion(sector.index = "d")
> circos.text(0.5, 0.5, "second one")
> circos.updatePlotRegion(sector.index = "c")
> circos.text(0.5, 0.5, "second one")
>
> circos.clear()
\end{Sinput}
\end{Schunk}

<<label=figseperated, include=FALSE, echo=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
factors = letters[1:4]
circos.par("canvas.xlim" = c(-1, 1.2), "canvas.ylim" = c(-1, 1.2), start.degree = -45, points.overflow.warning = FALSE)
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), bg.col = NA, bg.border = NA)
circos.updatePlotRegion(sector.index = "a")
circos.text(0.5, 0.5, "first one")
circos.updatePlotRegion(sector.index = "b")
circos.text(0.5, 0.5, "first one")

circos.clear()

par(new = TRUE)
circos.par("canvas.xlim" = c(-1.2, 1), "canvas.ylim" = c(-1.2, 1), start.degree = -45)
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), bg.col = NA, bg.border = NA)
circos.updatePlotRegion(sector.index = "d")
circos.text(0.5, 0.5, "second one")
circos.updatePlotRegion(sector.index = "c")
circos.text(0.5, 0.5, "second one")

circos.clear()
@

\begin{figure}
\begin{center}
<<label=figseperated, fig = TRUE, echo = FALSE>>=
<<figseperated>>
@
\end{center}
\caption{Two seperated circos layouts}
\label{fig:twoseperate}
\end{figure}

\subsection{Drawing outside and combine with canvas coordinate}
Sometimes it is very useful to draw something outside the plotting region of cell. The following is a simple
example to illustrate such circumstance (figure \ref{fig:outside}). The text is drawn outside the cell.

\begin{Schunk}
\begin{Sinput}
> set.seed(12345)
> par(mar = c(1, 1, 1, 1))
> factors = letters[1:4]
> circos.par("canvas.xlim" = c(-1.5, 1.5), "canvas.ylim" = c(-1.5, 1.5),
+     "gap.degree" = 10)
> circos.initialize(factors = factors, xlim = c(0, 1))
> circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
+     circos.points(1:20/20, 1:20/20)
+ })
> circos.lines(c(1/20, 0.5), c(1/20, 3), sector.index = "d", straight = TRUE)
> circos.text(0.5, 3, "mark", sector.index = "d", adj = c(0.5, 0))
>
> circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
+     circos.points(1:20/20, 1:20/20)
+ })
> text(0, 0, "this is\nthe center", cex = 1.5)
> legend("bottomleft", pch = 1, legend = "this is the legend")
>
> circos.clear()
\end{Sinput}
\end{Schunk}

Since the finnal graph is drawn in the ordinary canvas plotting region, we can add additional graphs through
the traditional way. You can also see how {\tt text} and {\tt legend} work in the above example code.


<<label=figoutside, include=FALSE, echo=FALSE>>=
library(circlize)
set.seed(12345)
par(mar = c(1, 1, 1, 1))
factors = letters[1:4]
circos.par("canvas.xlim" = c(-1.5, 1.5), "canvas.ylim" = c(-1.5, 1.5), "gap.degree" = 10)
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.points(1:20/20, 1:20/20)
})
circos.lines(c(1/20, 0.5), c(1/20, 3), sector.index = "d", straight = TRUE)
circos.text(0.5, 3, "mark", sector.index = "d", adj = c(0.5, 0))

circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.points(1:20/20, 1:20/20)
})
text(0, 0, "this is\nthe center", cex = 1.5)
legend("bottomleft", pch = 1, legend = "this is the legend")
circos.clear()
@

\begin{figure}
\begin{center}
<<label=figoutside, fig = TRUE, echo = FALSE>>=
<<figoutside>>
@
\end{center}
\caption{Drawing outside the cell and combine with canvas coordinate}
\label{fig:outside}
\end{figure}



\end{document}
